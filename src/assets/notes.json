[
    {
        "Note": "There are 3 java patters - 1. Creational 2. Structural 3. Behavorial",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Introduction & Prerequisites",
        "Clip": "Pattern Classifications",
        "Time in Clip": "0:06",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m1-intro&clip=2&mode=live&start=6.129842&noteid=4017c851-44fc-415d-be69-dc9122a21f1e",
        "Tags": [
            "#java",
            "#javaPatterns"
        ]
    },
    {
        "Note": "Thes patterns talk about how any object is used",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Introduction and Prerequisites",
        "Clip": "Which Patterns?",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m1&clip=3&mode=live&start=0.672517&noteid=0034813c-928d-47bd-8a0e-98e69693dc36",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern"
        ]
    },
    {
        "Note": "Singleton, Builder, Prototype, Factory, AbstractFactory",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Introduction & Prerequisites",
        "Clip": "Which Patterns?",
        "Time in Clip": "0:12",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m1-intro&clip=3&mode=live&start=12.693478&noteid=8b73bcc0-5bdf-48b0-9350-06e5eb57bfa2",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#creationalPattern"
        ]
    },
    {
        "Note": "ThreadScheduler is responsible for scheduling.",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Understanding Concurrency, Threading, and Synchronization",
        "Clip": "CPU Time Sharing Using a Thread Scheduler",
        "Time in Clip": "0:17",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m1&clip=5&mode=live&start=17.33679&noteid=8dde1064-47b9-490c-bff8-620032134ab1",
        "Tags": [
            "#java"
        ]
    },
    {
        "Note": "CPU resources should be shared equally",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Understanding Concurrency, Threading, and Synchronization",
        "Clip": "CPU Time Sharing Using a Thread Scheduler",
        "Time in Clip": "0:58",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m1&clip=5&mode=live&start=58.182477&noteid=181c5697-e07e-4f48-b540-1ac22cb91f53",
        "Tags": [
            "#java"
        ]
    },
    {
        "Note": "race condition - When data is accessed concurrently. When 2 different threads are reading and writing same data at same time.",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Understanding Concurrency, Threading, and Synchronization",
        "Clip": "What Is a Race Condition in Concurrent Programming?",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m1&clip=6&mode=live&start=0.500394&noteid=2c838528-2ed6-45bd-8944-ff8ac125aee6",
        "Tags": [
            "#java"
        ]
    },
    {
        "Note": "It is used to connect new code to leacy code.",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Introduction and Prerequisites",
        "Clip": "Next",
        "Time in Clip": "0:13",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m1&clip=6&mode=live&start=13.669373&noteid=a58d12fe-be79-433e-88a4-248af523166b",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#adapterDesignPattern"
        ]
    },
    {
        "Note": "Possible to put final, Annotation in lambda expressions",
        "Course": "From Collections to Streams in Java 8 Using Lambda Expressions",
        "Module": "Lambda Expressions and Functional Interfaces",
        "Clip": "Lambda Expression: Remarks and Precisions",
        "Time in Clip": "0:51",
        "URL": "https://app.pluralsight.com/player?course=java-8-lambda-expressions-collections-streams&author=jose-paumard&name=java-8-lambda-expressions-collections-streams-m1&clip=8&mode=live&start=51.919229&noteid=5b6d45ca-7021-4495-a0d8-4c69b552d799",
        "Tags": [
            "#java",
            "#lambdaExpression"
        ]
    },
    {
        "Note": "synchronization helps in removing  race conditions",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Understanding Concurrency, Threading, and Synchronization",
        "Clip": "Synchronizing Code to Prevent Race Conditions",
        "Time in Clip": "3:09",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m1&clip=8&mode=live&start=189.027541&noteid=4727b453-5f40-47db-8460-b70998b4bcf0",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "Also, we cannot specify the return type of lambda execution. Also, it is posible to omit the data types of elements taken as input in lambda expressions.",
        "Course": "From Collections to Streams in Java 8 Using Lambda Expressions",
        "Module": "Lambda Expressions and Functional Interfaces",
        "Clip": "Method References: A First Example with an Instance Method",
        "Time in Clip": "0:37",
        "URL": "https://app.pluralsight.com/player?course=java-8-lambda-expressions-collections-streams&author=jose-paumard&name=java-8-lambda-expressions-collections-streams-m1&clip=9&mode=live&start=37.394758&noteid=225c61ac-a1bf-49d8-b9dc-b903ed129137",
        "Tags": [
            "#java",
            "#lambdaExpression"
        ]
    },
    {
        "Note": "Alternative to \\nwriting lambda expressions -> Method references. \\nFunction<Person, Integer> f = Person::getAge;",
        "Course": "From Collections to Streams in Java 8 Using Lambda Expressions",
        "Module": "Lambda Expressions and Functional Interfaces",
        "Clip": "Method References: A First Example with an Instance Method",
        "Time in Clip": "0:38",
        "URL": "https://app.pluralsight.com/player?course=java-8-lambda-expressions-collections-streams&author=jose-paumard&name=java-8-lambda-expressions-collections-streams-m1&clip=9&mode=live&start=38.901252&noteid=aae09098-b7aa-49f7-9448-9cc5dfaf34fd",
        "Tags": [
            "#java",
            "#lambdaExpression"
        ]
    },
    {
        "Note": "Person::getAge i.e Classname::nameOfFuntion",
        "Course": "From Collections to Streams in Java 8 Using Lambda Expressions",
        "Module": "Lambda Expressions and Functional Interfaces",
        "Clip": "Method References: A First Example with an Instance Method",
        "Time in Clip": "0:40",
        "URL": "https://app.pluralsight.com/player?course=java-8-lambda-expressions-collections-streams&author=jose-paumard&name=java-8-lambda-expressions-collections-streams-m1&clip=9&mode=live&start=40.299782&noteid=9c4a972c-6b16-44dc-bee0-03cd96a9d205",
        "Tags": [
            "#java",
            "#lambdaExpression"
        ]
    },
    {
        "Note": "Method references should not be confused with static method",
        "Course": "From Collections to Streams in Java 8 Using Lambda Expressions",
        "Module": "Lambda Expressions and Functional Interfaces",
        "Clip": "Method References: A Second Example with a Static Method",
        "Time in Clip": "1:52",
        "URL": "https://app.pluralsight.com/player?course=java-8-lambda-expressions-collections-streams&author=jose-paumard&name=java-8-lambda-expressions-collections-streams-m1&clip=10&mode=live&start=112.060965&noteid=84773654-e5f0-4bd1-b8f2-e51e7b3380e3",
        "Tags": [
            "#java",
            "#lambdaExpression"
        ]
    },
    {
        "Note": "So, lambd expressions is a new syntax. \\nIt is a new way to define instances of anonymous class(interfaces). \\nAn alternative is : Method references",
        "Course": "From Collections to Streams in Java 8 Using Lambda Expressions",
        "Module": "Lambda Expressions and Functional Interfaces",
        "Clip": "Method References: The System.out.println Pattern",
        "Time in Clip": "1:23",
        "URL": "https://app.pluralsight.com/player?course=java-8-lambda-expressions-collections-streams&author=jose-paumard&name=java-8-lambda-expressions-collections-streams-m1&clip=11&mode=live&start=83.618196&noteid=fc92f3c6-0242-42d5-9043-820bb618f157",
        "Tags": [
            "#java",
            "#lambdaExpression"
        ]
    },
    {
        "Note": "deadlock is a situation where threads are waiting for each other for key to locks",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Understanding Concurrency, Threading, and Synchronization",
        "Clip": "What Is a Deadlock?",
        "Time in Clip": "1:49",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m1&clip=12&mode=live&start=109.577384&noteid=76c551bf-f132-4e98-862d-55e6cdfaf231",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "\\nOnly one instance is created.",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Singleton Pattern",
        "Clip": "Introduction",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m2-singleton&clip=0&mode=live&start=0.160756&noteid=0050104d-19c3-48c9-bb18-7a121f28bdd2",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#singletonDesignPattern"
        ]
    },
    {
        "Note": "\\n- Provides authentication and authorization out of the box\\n- Application layer framework\\n- Loosely coupled",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Introduction: Why Spring Security?",
        "Clip": "Introduction",
        "Time in Clip": "0:41",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=2d9fad22-4406-4476-98cf-10c44fbb82a9&clip=0&mode=live&start=41&noteid=0c6ece6a-0ead-4a79-a06c-15eacad3c710",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "\\n1. Microservices are small\\n2. They are independent\\n3. No inducing downtime in other services\\n4. They don't require Orchestration with other services. (This is the most important aspect of a microservice that they should be able to deploy without depending on some other microservice)\\n5. Microservices only communicate via API and no other of communication is allowed",
        "Course": "Microservices: Getting Started",
        "Module": "Understanding the Benefit of Microservices",
        "Clip": "Defining Monoliths and Microservices",
        "Time in Clip": "1:55",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=ff9eaeab-b0dc-4532-a983-a4cd2bac2268&clip=0&mode=live&start=115&noteid=92db266b-fa92-4fa1-8e9d-4f9251160784",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "There are multiple layers of security nowadays. For eg -\\n1. Firewall\\n2. Login\\n3. Security Questions\\n4. 2 factor authentication\\n5. Authorization\\n6. Hashing/Encryption",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Introduction: Why Spring Security?",
        "Clip": "Introduction",
        "Time in Clip": "2:15",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=2d9fad22-4406-4476-98cf-10c44fbb82a9&clip=0&mode=live&start=135&noteid=ca9602f0-d31a-47d3-af0b-667f4de0d088",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "What should be the size of the microservices correctly?\\n- Bounded context for scope: Derived from domain driven design. \\n - This is a strategic design pattern\\n- The microservices should be simple, cohesive enough to scale out at any given point. Also it should be easily deployable without much impact to the previous services",
        "Course": "Microservices Architectural Design Patterns Playbook",
        "Module": "How to Scope Microservices Using Bounded Contexts",
        "Clip": "Need for Scoping Microservices",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=microservices-architectural-design-patterns-playbook&author=rag-dhiman&name=fe1f5154-903d-4e78-8704-555225d33128&clip=1&mode=live&start=0&noteid=ae83c960-ebe5-4135-8570-2351bb19ac14",
        "Tags": [
            "#microservice",
            "#design"
        ]
    },
    {
        "Note": "Testing is just code. which is a test class which executed the code to test",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing Your First Test",
        "Clip": "The Benefits of Unit Testing",
        "Time in Clip": "0:11",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=b3eefdf6-eba5-47d6-8634-badf5a8831c7&clip=1&mode=live&start=11.094954&noteid=15a951d3-0537-4d7c-9404-7f4127d0c584",
        "Tags": [
            "#java",
            "#testing"
        ]
    },
    {
        "Note": "Example - \\nInt[] arr= new int[]{1, 2}\\nArrays.asList(arr)\\n\\nThis is an adapter of Array for adapting arrays to List",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Adapter Design Pattern",
        "Clip": "Plug Adapter",
        "Time in Clip": "0:25",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m2&clip=1&mode=live&start=25.824367&noteid=f6fb1c6e-7666-4300-8ed8-fc01e568ef30",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#adapterPattern"
        ]
    },
    {
        "Note": "\\n1. ms should be small enough to be rewritten if necessary.\\n2. They own their own data, this means that only that ms has access to that data. If anyone else wants to get that data, then they have to go through the public APIs exposed to them\\n3. autonomous, independently deployable servicse",
        "Course": "Building Microservices",
        "Module": "Getting Started with Building Microservices",
        "Clip": "Microservices Give You Options",
        "Time in Clip": "0:48",
        "URL": "https://app.pluralsight.com/player?course=building-microservices&author=mark-heath&name=30a97456-ebec-4c9a-bffd-6b296463dde4&clip=1&mode=live&start=48&noteid=e4d0dfef-2d11-4630-9866-62392c849b0e",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Verify small pieces of a complex system",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing Your First Test",
        "Clip": "The Benefits of Unit Testing",
        "Time in Clip": "1:26",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=b3eefdf6-eba5-47d6-8634-badf5a8831c7&clip=1&mode=live&start=86.15816&noteid=22e71841-c67b-44af-9acf-189beee71bb8",
        "Tags": [
            "#java",
            "#testing",
            "#junits"
        ]
    },
    {
        "Note": "Helps in designing. Also acts as documentation",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing Your First Test",
        "Clip": "The Benefits of Unit Testing",
        "Time in Clip": "2:12",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=b3eefdf6-eba5-47d6-8634-badf5a8831c7&clip=1&mode=live&start=132.831759&noteid=d484aadd-9f57-4269-be2e-fcae47e697a9",
        "Tags": [
            "#java",
            "#testing",
            "#junits"
        ]
    },
    {
        "Note": "-driven When Microservices become huge and there is a lot of dependency on each other, its becomes a hell. \\n\\nSo, ***Event-drive architecture(EDA)*** came into picture. A software architecture pattern promoting the production, detection, consumption of, and reaction to events.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "Enterprise Software Architectures",
        "Time in Clip": "3:03",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=1&mode=live&start=183&noteid=00aa342a-b515-4765-81d5-d3ee9871e203",
        "Tags": [
            "#kafka",
            "#even"
        ]
    },
    {
        "Note": "-driven So, everything revolves around events in EDA\\n\\nEDA applications -\\n1. Microservices\\n2. Serverless\\n3. Faas(Function as a service)\\n4. Streaming\\n5. Event sourcing\\n6. CQRS(Command query request segregation)",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "Enterprise Software Architectures",
        "Time in Clip": "3:18",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=1&mode=live&start=198&noteid=b9c9be41-dd76-4615-9ce8-1891051a7c82",
        "Tags": [
            "#kafka",
            "#event"
        ]
    },
    {
        "Note": "Singleton is responsible fo its creation and lifecycle of it.\\nneeds to be thread safe",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Singleton Pattern",
        "Clip": "Design Considerations",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m2-singleton&clip=2&mode=live&start=0.018412&noteid=018f7049-e59c-4961-894d-106103934a88",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#singletonDesignPattern"
        ]
    },
    {
        "Note": "**Domain Driven Design** \\n- We model software based on the read world domain problems. \\n- So, we use take the domain knowledge of the real world problem and try to model our systems on the same way. We are forced to think of some boundaries present around our microservices.\\n- This boundaries are said to be bounded contexts and each represents a domain function\\n- The design encourages \\n - Loose coupling: By thinking inside f the context we make the services inherently loosely coupled \\n - High cohesion: Also, the think which should not be present in the context is places outside of the bounded context giving rise to the services to be cohesive.\\n",
        "Course": "Microservices Architectural Design Patterns Playbook",
        "Module": "How to Scope Microservices Using Bounded Contexts",
        "Clip": "Domain Driven Design",
        "Time in Clip": "0:01",
        "URL": "https://app.pluralsight.com/player?course=microservices-architectural-design-patterns-playbook&author=rag-dhiman&name=fe1f5154-903d-4e78-8704-555225d33128&clip=2&mode=live&start=1&noteid=3d0230e7-02aa-46b1-9736-c57c20204142",
        "Tags": [
            "#microservice",
            "#design"
        ]
    },
    {
        "Note": "Docker Networking pillars -\\n- CNM(Container Network Model): Specification doc on github on how the networking model should be. The 3 main constructs of CNM are: \\n - Sandbox: aka namespace, i.e the space in the OS which can be done in isolation. We can create full n/w stack in this sandbox - IP config, routing tables, DNS. \\n - Endpoint: This are n/w interfaces. For eg - eth0\\n - Network: Connected endpoints which can talk with each other\\n- Libnetwork: This is the real world implementation of CNM written in Go. \\n - This is the center plave for all docker networking. \\n - Pluggable\\n- Drivers: These states the details for each type of driver. There are native drivers  and also 3rd party drivers(remote)\\n - Overlay\\n - Brigde\\n - MACVLAN\\n - IPVLAN",
        "Course": "Docker Networking",
        "Module": "The Basics",
        "Clip": "The Three Pillars of Docker Networking",
        "Time in Clip": "0:21",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m1&clip=2&mode=live&start=21&noteid=01043861-c6b0-4ac4-bc8c-5cd8ee95bb0c",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "pom.xml can be divided into 4 parts -\\n1. Project information - contains groupId articfactId, version, packaging\\n2. Dependencies - direct dependencies used in our app\\n3. Build - which plugins to use, change directory structure, \\n4. Repositories - where to download the repositories",
        "Course": "Maven Fundamentals",
        "Module": "Maven Structure",
        "Clip": "The pom.xml",
        "Time in Clip": "0:49",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m2&clip=2&mode=live&start=49.48245&noteid=2c3ae20a-2153-4c70-8eb6-c874cfb59e4f",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "\\n- CNM: Design/DNA for n/w\\n- Libnetwork: Control plane and management plane\\n- Drivers: Data plane",
        "Course": "Docker Networking",
        "Module": "The Basics",
        "Clip": "The Three Pillars of Docker Networking",
        "Time in Clip": "6:37",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m1&clip=2&mode=live&start=397&noteid=e598445b-066e-42e6-b3b1-680ce6b60cc9",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Bounded Context: A specific responsibility enforced by an explicit boundary which is completely inline of our microservice.\\n- Our microservice can have boundaries based on buisness domain, etc.\\n- So, we start of by identifying the core domain concepts. For eg:\\n - If we have delivery, driver, Customer orders in the domain - \\n - Then delivery signing, delivery invoicing and other things will come under this domain. \\n  - This then becomes the boundary of our bounded context. \\n- Each BC has an explicit interface and this acts like a communication to other services. This interface should define the i/p and o/p of that microservice.\\n- The communication is taken care by shared models for communication.\\n- We should keep in mind to not use models internal to the bounded context\\n- Every boundary of the microservice will have its own repositry and data store",
        "Course": "Microservices Architectural Design Patterns Playbook",
        "Module": "How to Scope Microservices Using Bounded Contexts",
        "Clip": "Bounded Context",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=microservices-architectural-design-patterns-playbook&author=rag-dhiman&name=fe1f5154-903d-4e78-8704-555225d33128&clip=3&mode=live&start=0&noteid=9728370a-0326-4b94-b880-bf7da8cad2d2",
        "Tags": [
            "#microservice",
            "#design"
        ]
    },
    {
        "Note": "-driven \\n1. Messages: A message is a basic unit of communication. It can be anything. It is a generic interface. It can be categorized as below \\n2. Events: An event is a message which notifies anyone who is listening.\\n3. Command: It is a command from the notifier to the receiver(Producer/Consumer)",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "EDA Benefits",
        "Time in Clip": "0:14",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=3&mode=live&start=14&noteid=523f5c78-94f0-45fd-9e46-a2a1b6ef79e9",
        "Tags": [
            "#kafka",
            "#event"
        ]
    },
    {
        "Note": "IPAM drivers are used for IP management and are pluggable",
        "Course": "Docker Networking",
        "Module": "The Basics",
        "Clip": "Hands on with the Basic Docker Networking Commands",
        "Time in Clip": "5:08",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m1&clip=3&mode=live&start=308&noteid=6c52b07c-f54e-43e6-a8fc-7f5a456def7e",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "-driven \\nBenefits of EDA\\n1. Decoupling\\n2. Encapsulation: Events can be classified b/w different boundaries and can be consumed respectively. \\n3. Optimization: real time against scheduling\\n4. Scalability:",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "EDA Drawbacks",
        "Time in Clip": "0:03",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=4&mode=live&start=3&noteid=a98d415e-2671-4420-af07-7a73668e6095",
        "Tags": [
            "#kafka",
            "#event"
        ]
    },
    {
        "Note": "-driven\\nDrawbacks of EDA\\n1. Steep learning curve\\n2. What happens if there are multiple same messages?\\n3. Complexity: It can become complex\\n4. Loss of transactionality:  We cannot rollback if something goes wrong\\n5. Lineage: we dont know from where the event arose as the services are decoupled",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "EDA Drawbacks",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=4&mode=live&start=4&noteid=4b1599dd-f1c9-4431-bd4a-657f8235df0f",
        "Tags": [
            "#kafka",
            "#event"
        ]
    },
    {
        "Note": "Goals - \\n1. clean - delete the generated files and target folder\\n2. compile - compile all source code, generate any files, copies resources to our cloass directory\\n3. package\\n4. install - runs the package command and then install it in local repo\\n5. deploy - runs the install command and then deploy it to a corporate repo",
        "Course": "Maven Fundamentals",
        "Module": "Maven Structure",
        "Clip": "Goals",
        "Time in Clip": "0:05",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m2&clip=4&mode=live&start=5.063646&noteid=ea56e428-39e8-450b-928f-b85f2ade2a44",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "synchronization if not properly used will create deadlocks",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Implementing the Producer/Consumer Pattern Using Wait / Notify",
        "Clip": "A First Synchronized Version of the Producer/Consumer",
        "Time in Clip": "1:48",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m2&clip=4&mode=live&start=108.725025&noteid=77c61960-7c6d-40c8-ae82-9e60b028aa39",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "\\n1. Hub and spoke architecture: Where all the API requests come through some API gateway and appropriately sent to respective microservices\\n2. EDA: Event-driven architecture where all the services talk using a message bus\\n3. Hybrid EDA + RPC Architecture: So, some services talk with each other using a message bus and other services talk with these services which are connected via message bus.",
        "Course": "Microservices: Getting Started",
        "Module": "Understanding the Benefit of Microservices",
        "Clip": "Example Microservice Architectures",
        "Time in Clip": "2:38",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=ff9eaeab-b0dc-4532-a983-a4cd2bac2268&clip=4&mode=live&start=158&noteid=e0f59eec-a958-4f02-9ea3-eb27f0908fd7",
        "Tags": [
            "#microservice"
        ]
    },
    {
        "Note": "-driven Event Storming & DDD are used to model EDA\\n\\n**Event Storming**: Events are classified in the following categories -\\n\\n1. Domain event: An event which is happening in the system and is relevant to the buisness. It can even evoke another event.\\n\\n2. Polivy event: A policy represents an event which is an event that starts with whenever.(For eg: notification of completion)\\n\\n3. External systems: External guy wants to talk to the system who doesn't have control over system. For eg: Payment interfaces \\n\\n4. Command: Actions which are generally part of the beginning of the trigger flow\\n\\n**DDD** Domain driven design:\\n\\n1. Aggregate: To model the s/w we need to Logically grouping events. The goal is to isolate like events together.\\n\\n2. Bounded context: This means the use of events in different sub-domains, i.e., how the events would be used different systems",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "Event Storming",
        "Time in Clip": "0:08",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=5&mode=live&start=8&noteid=09a4732f-c163-413d-a842-51dace896540",
        "Tags": [
            "#kafka",
            "#event"
        ]
    },
    {
        "Note": "\\n1. Small\\n2. Variety of tech stacks\\n3. Independent deployment(No orchestration)\\n4. Microservices help organize teams\\n5. Concentrate expertise\\n6. Independent governance. So, each ms is in itself is responsible for itself without worrying about the whole.\\n7. Balance decentralized decision-making with elevation of important topics\\n\\n8. Easier to maintain as you need to maintain each small ms.\\n9. Performance management at scale with low cost since you can scale a single ms which is more critical.\\n10. Reinforce architectural boundaries. Since in a monolith it usually happens that the architectural boundaries fade away with new features.. etc.\\n\\n11. Resilience: Since we need to only have more emphasis on the customer-facing services to maintain some SLA. It is even more easier to maintain them by tuning only respective ms.\\n12. Isolate risky and buggy code through an ms to reduce the overall impact only on that particular ms\\n13. Isolate third-party fault handling",
        "Course": "Microservices: Getting Started",
        "Module": "Understanding the Benefit of Microservices",
        "Clip": "Review",
        "Time in Clip": "0:10",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=ff9eaeab-b0dc-4532-a983-a4cd2bac2268&clip=5&mode=live&start=10&noteid=1a14abd6-1a4d-4c98-864a-a05b7ccc4640",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "-driven Event storming & DDD \\n\\nWe should have a timeline of all the event in the system\\n\\n**Miro tool**\\n\\nBrain storm on all the events",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Experiencing the Impact of an Event-driven Architecture",
        "Clip": "Demo: Event Storming",
        "Time in Clip": "0:30",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c3826ce8-969d-4e56-b170-b62285943c7c&clip=6&mode=live&start=30&noteid=4c17393b-5539-4ea9-bc3a-8fdb61ca7301",
        "Tags": [
            "#kafka",
            "#event"
        ]
    },
    {
        "Note": "Steps to practice bounded practice:\\n- We first try to understand the core concepts of the service by thinking of domain functions.\\n - For eg. we have delivery and Customer Orders\\n- Then we start finding contexts in each binding contexts.\\n- Then we also try to define a language for each particular microservice\\n- We also need to find supporting contexts. For eg: Drivers can be supporting concept for the delivery since: \\n - The driver is a part of bigger whole shifts, transport, Annual leaves, etc.\\n- Also, if any bounded contexts starts to interact with a context which does not fit the natural language of the bounded context, then most likely this context will integrate with that context\\n",
        "Course": "Microservices Architectural Design Patterns Playbook",
        "Module": "How to Scope Microservices Using Bounded Contexts",
        "Clip": "Scoping Using Bounded Contexts",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=microservices-architectural-design-patterns-playbook&author=rag-dhiman&name=fe1f5154-903d-4e78-8704-555225d33128&clip=7&mode=live&start=7&noteid=9372cafd-ce07-46e5-ad8e-5b4995989e50",
        "Tags": [
            "#microservice",
            "#design"
        ]
    },
    {
        "Note": "Also we sometimes aggregate the bounded contexts once we have broken them down since we may need -\\n- Reporting \\n- Enhanced functionality maybe needed to provide more func to clients\\n- Performance\\n- Usability for clients",
        "Course": "Microservices Architectural Design Patterns Playbook",
        "Module": "How to Scope Microservices Using Bounded Contexts",
        "Clip": "Aggregation",
        "Time in Clip": "0:36",
        "URL": "https://app.pluralsight.com/player?course=microservices-architectural-design-patterns-playbook&author=rag-dhiman&name=fe1f5154-903d-4e78-8704-555225d33128&clip=8&mode=live&start=36&noteid=2723a411-9a45-47d6-b030-ded49399244c",
        "Tags": [
            "#microservice",
            "#design"
        ]
    },
    {
        "Note": "Threads deadlock can be found in debug mode",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Implementing the Producer/Consumer Pattern Using Wait / Notify",
        "Clip": "Understanding the States of a Thread",
        "Time in Clip": "0:38",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m2&clip=12&mode=live&start=38.843169&noteid=3b262b7a-db42-4536-8841-1cd5f8456417",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "Thread states - NEW - When thread is newly created. RUNNABLE - When thread.start() is invoked. TERMINATED - When thread should not be scheduled",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Implementing the Producer/Consumer Pattern Using Wait / Notify",
        "Clip": "Understanding the State Diagram of a Thread",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m2&clip=13&mode=live&start=4.335489&noteid=3b2df907-d7f8-4085-ac72-a39a812e1ac9",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "Other states in RUNNABLE states - 1. BLOCKED - blocked for lock. 2. WAITING - waiting in wait line. can bee released by notify().",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Implementing the Producer/Consumer Pattern Using Wait / Notify",
        "Clip": "Understanding the State Diagram of a Thread",
        "Time in Clip": "1:59",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m2&clip=13&mode=live&start=119.402107&noteid=e1e27818-0170-4122-8230-f304113f05af",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "Thread.getState() gives the state of a thread",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Implementing the Producer/Consumer Pattern Using Wait / Notify",
        "Clip": "Wrap-up on the State of a Thread",
        "Time in Clip": "1:04",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m2&clip=14&mode=live&start=64.787022&noteid=b7cf98e5-80e1-4fb1-82ae-e592cd0ea934",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "Challenges of ms:\\n1. They are complex\\n2. As they are distributed systems, there are challenges which are quite different compared to monoliths\\n3. N/w performance concerns: So, more coarsed-grained designs, avoiding chatty behaviour should me minimized.\\n",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Microservices Are Hard",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=0&mode=live&start=7&noteid=6563d280-8a28-4a23-a9a1-144e6d91b862",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Spring boot enables Spring security by default",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Introduction",
        "Time in Clip": "0:31",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=0&mode=live&start=31&noteid=381502ef-160e-46e0-bdbe-7130be055f6e",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Any request is sent to the server. The server sends the requests to servlets to serve the request.\\n\\nBut there are filters in b/w who can check the request and forward it to the next filter.\\n\\nSpring security heavily uses these filters",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "High-level View of Spring Security",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=1&mode=live&start=0&noteid=d7b78c1a-9eb2-41eb-9821-671c7425dd84",
        "Tags": [
            "#spring",
            "#security",
            "#legacy"
        ]
    },
    {
        "Note": "Single Host networking with bridge:\\n- The network is only going to be present only on the that machine. \\n- Creating a bridge n/w creates a new virtual switch on the machine\\n - This is a kernel feature on linux hence it is very fast and reliable\\n- Command: docker network create d bridge --subnet 10.0.0.1/24 ps-bridge\\n",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Single-host Networking",
        "Time in Clip": "0:05",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=1&mode=live&start=5&noteid=f6b15404-3927-41d2-9be4-2ab3ce898f8e",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "\\n1. It is meant to decouple abstraction and implementation.\\n2. Encapsulation, Composition, Inheritance\\n3. Changes in Abstract wont affect client.\\n\\n\\n",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Bridge Design Pattern",
        "Clip": "Concepts",
        "Time in Clip": "0:06",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m3&clip=1&mode=live&start=6.384204&noteid=c2613a42-2c0d-4c03-abde-553f4e896331",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#bridgePattern"
        ]
    },
    {
        "Note": "To enable spring security, we need to register DelegatinFilterProxy which delegates the security handling to other security check components.",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "High-level View of Spring Security",
        "Time in Clip": "0:51",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=1&mode=live&start=51&noteid=f392b084-4a34-4d39-bf9d-d92cc3e60228",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Kafka cluster is a grouping of brokers on machine. The brokers can be on different machines.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "The Apache Kafka Cluster",
        "Time in Clip": "1:11",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=1&mode=live&start=71&noteid=0c9d04bb-f1e8-4aee-b552-d098028a990c",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "assertSame() returns if both the objects are same, i.e, enum or other things.",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing More Complex Tests ",
        "Clip": "Demo: Applying Assertions",
        "Time in Clip": "1:36",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=8f3dd63e-8e33-4fd3-a7c4-f4215fda7caf&clip=1&mode=live&start=96.424882&noteid=fd8ce27a-b91f-4742-b55e-722b60bf449f",
        "Tags": [
            "#java",
            "#junits",
            "#assertions"
        ]
    },
    {
        "Note": "It is written in Scala and Java both and runs on JVM",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Apache Kafka Application",
        "Clip": "Why Kafka?",
        "Time in Clip": "1:46",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=da300bcb-2b61-4801-a737-85371bfff2e4&clip=1&mode=live&start=106&noteid=264d148b-d1f9-40df-801c-0e714efe744d",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "The delegating filter proxy delegates the task to another FilterChainProxy which delegates to \"SecurityFilterChain\". This is the main filter chains which are used to configure security",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "High-level View of Spring Security",
        "Time in Clip": "2:31",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=1&mode=live&start=151&noteid=bc84b1de-3dc7-4fe4-badc-b830df1a06eb",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Broker is a software service that stores messages on the system. It is responsible is for all the message trasmission.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "The Apache Kafka Cluster",
        "Time in Clip": "2:36",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=1&mode=live&start=156&noteid=20d9a38a-e39d-4a8f-b49b-c9a6948bba71",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "Main reasons to use kafka: \\n\\n1. No serialization/Deserealiazation  present insode kafka. Eventhing is present in normal binary form.\\n\\n2. Zero copy: Data is generally stored in RAM first and them moved to HDD. This results in some overhead. Hence, kafka direclty stores the data in HDD. Basically in log files. Hence the name zero copy\\n\\n3. Written in JAVA\\n\\n4. Distributes Streaming platform: It is more than messaging system.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Apache Kafka Application",
        "Clip": "Why Kafka?",
        "Time in Clip": "2:40",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=da300bcb-2b61-4801-a737-85371bfff2e4&clip=1&mode=live&start=160&noteid=428e1ce2-d793-46b9-813f-f47b4f1935cf",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "assertEquals on collections in java makes use of the equals method.",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing More Complex Tests ",
        "Clip": "Demo: Applying Assertions",
        "Time in Clip": "5:09",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=8f3dd63e-8e33-4fd3-a7c4-f4215fda7caf&clip=1&mode=live&start=309.932342&noteid=445f723c-42b4-4b12-8013-3824a5625655",
        "Tags": [
            "#java",
            "#junits"
        ]
    },
    {
        "Note": "The assertIterableEquals can be used for collection assertions",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing More Complex Tests ",
        "Clip": "Demo: Applying Assertions",
        "Time in Clip": "5:09",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=8f3dd63e-8e33-4fd3-a7c4-f4215fda7caf&clip=1&mode=live&start=309.932342&noteid=0612aa7e-dd48-4463-b04f-d41ba59bd40f",
        "Tags": [
            "#java",
            "#junits"
        ]
    },
    {
        "Note": "\\n- bridge-tools: linux tools to check bridge n/w. brctl show\\n- ip link show",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Single-host Networking",
        "Time in Clip": "5:58",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=1&mode=live&start=358&noteid=e9b46ca1-a8e9-4a02-96aa-7ef2726824a4",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "When we create a container with some network, they get the eth0 virtual ethernet adapter which is plummed into the network switch.",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Single-host Networking",
        "Time in Clip": "7:39",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=1&mode=live&start=459&noteid=92104609-c4ef-49f8-89c2-004f95cf741b",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Whenever a service/container is put onto the network, the name is registered into the DNS service. Hence, we can discover the service",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Single-host Networking",
        "Time in Clip": "9:41",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=1&mode=live&start=581&noteid=5abc84c3-2512-4626-9053-abaeb1b1b58b",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Distributed system is a collection of resources that can achieve a specific goal. There are multiple nodes present which needs to be in coordination.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Principles of Distributed Systems",
        "Time in Clip": "0:08",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=2&mode=live&start=8&noteid=4ad688bd-5c20-43fb-8dfb-8ab2707cdc1e",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "Example - JDBC Driver. So, the implementation is decoupled from the abstraction. The user doesn't know about the underlying implementation",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Bridge Design Pattern",
        "Clip": "Design Considerations",
        "Time in Clip": "0:10",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m3&clip=2&mode=live&start=10.889735&noteid=ea2c5775-3c7f-4b0b-9151-14736db10cb7",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#bridgePattern"
        ]
    },
    {
        "Note": "Junit lifecycle annotations: 1. @BeforeAll - runs before all tests once. 2. @BeforeEach 3. @Test 4. @AfterEach 5. @AfterAll",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing More Complex Tests ",
        "Clip": "Demo: Setting up and Tearing Down Tests",
        "Time in Clip": "0:29",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=8f3dd63e-8e33-4fd3-a7c4-f4215fda7caf&clip=2&mode=live&start=29.88498&noteid=2d88818e-d0ce-4e1d-973c-4912f06583a4",
        "Tags": [
            "#java",
            "#junits"
        ]
    },
    {
        "Note": "MS are autonomous, independently deployable",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Microservices Own Their Own Data",
        "Time in Clip": "0:35",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=2&mode=live&start=35&noteid=b93b0ac2-3fa6-4a45-9795-0be93722e6e5",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "Microservice Data should own their own data. So, the data should cannot be shared but can be accessed via public APIs\\nLimitation:\\n- Cannot have DB joins\\n- Transactions would have to be distributed\\n",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Microservices Own Their Own Data",
        "Time in Clip": "0:35",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=2&mode=live&start=35&noteid=2dd8731a-538d-49ef-974f-ea49d62d84de",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "SecurityFilterChain interface contains -\\n1. matches() - This tells if the request matches the criteria for me to perform security checks onto it.\\n2. List<Filter> getFilters() - Returns the filters which will perform the checks",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "The Architecture of the Spring Security Filter Chains",
        "Time in Clip": "1:13",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=2&mode=live&start=73&noteid=944d288f-0092-4c21-a696-1711f27d09a3",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "FilterChain details -\\n1. SecurityContextPersistenceFitler: Contains the \"Security context\" which would have security related to checks. For eg. User Principle, tokens, etc.\\n\\nIf the request is not authenticated ever before. The security Context is initialized.\\n\\n2. Authentication Filters: Once the filter authenticates the request, the Authentication is placed in the SecurityContext. So, that the request does not need to authenticate again.\\n\\n3. RememberMeAuthenticationFilter\\n4. AnonymousAuthenticationFilter: In case the reqest could not be authenticated.\\n5. ExceptionTransaltionFitler: This can be used to tell the user to tell them that they need authentication. \\n6. FilterSecurityInterceptor: Performs authorization. So, it checks if the authentication principle has authorization to access the resource.",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "The Architecture of the Spring Security Filter Chains",
        "Time in Clip": "1:32",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=2&mode=live&start=92&noteid=4e617506-4681-4c78-b28a-1dd25bba637a",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "The distribution of stateful logic across independent systems is a hard problem.\\n\\ni.e, how the events/processes in a microservice should look like needs to handled carefully. For eg.\\n1. Payment gateway service\\n2. validator of req\\nHere if the validator fails and the payment succeeds it will lead to probelms\\n",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Resilience of Network Communications",
        "Time in Clip": "1:43",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=2&mode=live&start=103&noteid=98cdafc5-05a8-4142-9e66-5da2d613ab4d",
        "Tags": [
            "#microservice"
        ]
    },
    {
        "Note": "To mitigate data distribution:\\n- Define service boundaries well \\n- Implement Caching\\n - Improved performance\\n - Improved availability",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Microservices Own Their Own Data",
        "Time in Clip": "2:30",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=2&mode=live&start=150&noteid=17e97573-4f15-4947-a6b8-7647b270f66f",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "Network concerns:\\n1. One ms is dependent on another ms. So, if some ms is on high load and not able to perform. Let's say the calling ms then calls the ms with a retry policy. So, this is something which will in turn increase the service. which can cause havoc in our service.\\n2.  Cascading Failure: The callee fails because of failing dependency. So, this becomes like a domino effect",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Resilience of Network Communications",
        "Time in Clip": "2:43",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=2&mode=live&start=163&noteid=6bd2f1cb-be0e-4766-b66e-92e53777787e",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "One worker node is elected to lead the workers. The lead worker keeps track of the inventory of all the worker nodes, resources, etc.\\n\\nAll of them together form a Kafka cluster",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Principles of Distributed Systems",
        "Time in Clip": "2:44",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=2&mode=live&start=164&noteid=fbce5901-be1d-4647-8f82-f58ec2ca7819",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "Multi-host networking: \\n- All the nodes on the the network have a sandbox inside which is created which has the network stack built inside them. \\n- Once this is done, a VTEP(Virtual tunnel end point) are exposed which are connectedvia VXLAN tunnel which is the actual overlay network.\\n- The router which is present doesn't know abt this n/w. Ofcourse it is used. And this is called layer2 adjacency.",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Multi-host Overlay Networking",
        "Time in Clip": "4:18",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=2&mode=live&start=258&noteid=05ff54d7-4df6-4224-be76-195ab659bef0",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "**VXLAN is a tunneling protocol that encapsulates Layer 2 Ethernet frames in Layer 3 UDP packets, enabling you to create virtualized Layer 2 subnets, or segments, that span physical Layer 3 networks. **",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Multi-host Overlay Networking",
        "Time in Clip": "5:38",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=2&mode=live&start=338&noteid=a03ee516-a172-4217-8932-bc235b97b31b",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "The overlay network is created on the other nodes in the swarm once any service needs to put on that network",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Multi-host Overlay Networking",
        "Time in Clip": "11:17",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=2&mode=live&start=677&noteid=d70e7e4d-2299-422a-b920-7d7391ec2242",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "The overlay n/w works by default. Also, the underlay network must be connected, i.e, these ports 4789(UDP), 7946(TCP/UDP), 2377(TCP)",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Multi-host Overlay Networking",
        "Time in Clip": "14:38",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=2&mode=live&start=878&noteid=b3d6f1e6-151d-46fd-8628-611ab2701af4",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "The filter creates an authentication token based on the authentication and delegates the task to AuthenticationManager",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "0:31",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=31&noteid=cd99348d-d4a3-4020-b209-a544141166af",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "MACVLAN\\n- Linux based n/w drivers\\n Bridge/overlay drivers are used to connect containers but can't be used to connect the containers onto existing n/w and MACVLAN is used to connect them\\n- MACVLAN gives every container\\n - its own IP\\n - its own MAC\\n- To add containers to the existing n/w, the hosts are connected to the existing n/w by creating a MACVLAN adapter. Then all the containers are connected to this adapter and it looks like they are part of the same n/w",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Joining Existing Networks with the MACVLAN Driver",
        "Time in Clip": "0:35",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=3&mode=live&start=35&noteid=bda449ae-6f57-47af-9d36-99cd61d776ae",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "AthenticationManager then calls the Authentication Provider(one or more).\\n\\nBasically, there are user data which the authentication provider uses.",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "0:46",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=46&noteid=944cae83-d7e2-43d0-9a02-177d49adb522",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Analysing logs and issues in a ms requires the correlation of the data collected from different services.\\n\\n- Because of this complexity, the observability of microservices is very crucial should be woven propery into the microservice.",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Running Microservices in Production",
        "Time in Clip": "1:02",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=3&mode=live&start=62&noteid=e83ed1d1-e802-47b6-95e9-7951efde7492",
        "Tags": [
            "#mocroservices"
        ]
    },
    {
        "Note": "Types =>\\nTypes refer to type of resource we want to include in our application. core packaging types are \\n- pom, jar, maven-plugin, ejb, war ear, rar, par\\n- default packaging is jar\\nThe type of pom is referred to as dependency pom\\n- downloads dependencies from that pom\\n",
        "Course": "Maven Fundamentals",
        "Module": "Maven Dependencies",
        "Clip": "Types",
        "Time in Clip": "1:02",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m3&clip=3&mode=live&start=62.312246&noteid=43c7feb4-6d51-4abd-aeeb-5aef75676bc1",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "The leader/controller picks the nodes based on the redundancy policy to enable robust nature\\n\\nThe factor which accounts for the redundancy policy is know as replication factor",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Reliable Work Distribution",
        "Time in Clip": "1:12",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=3&mode=live&start=72&noteid=f25e0b32-7196-4b32-bb4d-961ab675e07b",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "There is a controller for a cluster. The controller then has leaders who take ownership of some tasks. Then there are worker nodes who do the work delegated from leaders.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Reliable Work Distribution",
        "Time in Clip": "1:14",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=3&mode=live&start=74&noteid=e708b8b9-7dd5-42c1-a7c8-0089f4a46328",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "So, the controller will elect leaders to delegate the incoming task. The leaders then have workers below them to get the task done. This is done by making a quorum.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Reliable Work Distribution",
        "Time in Clip": "1:19",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=3&mode=live&start=79&noteid=5d6c05af-a883-4730-aedc-653243b8e40b",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "Authentication authenticates the user from the provider and returns a token",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "1:20",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=80&noteid=3088b0d5-bdea-4367-ae0a-6d689b9604c1",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "visibility in multiple cores says that a variable in visible if all the writes on the variable are visible",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Ordering Read and Writes Operations on a Multicore CPU",
        "Clip": "Definition of Visibility on Multicore CPUs",
        "Time in Clip": "1:41",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m3&clip=3&mode=live&start=101.657392&noteid=9354c588-f679-4d1c-b6bc-5d924a7e4a46",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "It is impossible to run ms without robust automation. For eg: testing, monitoring, deployments\\n\\nSo, manual processes needs to be eliminated",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Running Microservices in Production",
        "Time in Clip": "1:58",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=3&mode=live&start=118&noteid=559729ff-7964-46d6-a4ef-a56de375839e",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Initially there will be the Authentication request which will have -\\nPrinciple - username\\nCredentials - password\\nAuthorities - Roles,etc",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "2:09",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=129&noteid=160e0aa8-0fa7-4057-be0c-c8e31099e2e4",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Once authenticated, it is known as authenticated Principle\\n\\nPrinciple will have UserDetails\\nCredentials will be be removed\\n\\nThe Authenticated Priniciple is stored in memory and accessible to the current thread",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "2:13",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=133&noteid=cf0228c2-06b5-4bc2-9b47-86fbd1436a3f",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Authentication interface:\\n1. isAuthenticated() : returns if the user is authenticated.\\n2. Principle: Has the User details on which the request would be authenticated.\\n3. getAuthorities(): returns the Authorities which the request has once authenticated. For eg: Roles: eg ADMIN, USER",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "2:21",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=141&noteid=f42d0a14-8e4a-42aa-abc1-795c7fb6ef0f",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "When a task comes, the controller needs to know worker availability and health. Also the policy for that work",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Reliable Work Distribution",
        "Time in Clip": "3:06",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=3&mode=live&start=186&noteid=83351b38-2db8-425f-a2bc-6789cb930cbc",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "AthenticationProvider uses a UserDetailsService to authenticate the user against",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "3:12",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=192&noteid=e8905f92-7623-4940-9eaa-08716907764d",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Interface of SecurityContext:\\n1. Authentication getAuthentication()\\n2. setAuthentication()\\n\\nSo, basically getter/setter for authentication",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "How Requests Are Authenticated",
        "Time in Clip": "4:04",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=3&mode=live&start=244&noteid=a31565dc-2620-4b4e-893f-fda432589a57",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Security also needs to be layered throughout the system to have a proper secure system",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Running Microservices in Production",
        "Time in Clip": "4:33",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=3&mode=live&start=273&noteid=dd2cb044-7f32-4f08-8458-34f9789bc781",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Transitive dependencies\\n- Maven downloads the transitive dependencies which are required for that dependency.\\n- Also gets the latest dependencies.\\n- Resolve conflicts as well",
        "Course": "Maven Fundamentals",
        "Module": "Maven Dependencies",
        "Clip": "Transitive Dependencies",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m3&clip=4&mode=live&start=7.776903&noteid=d3a486b5-f89f-4728-b4da-26848189c412",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "\\n1. AuthenticationFilter generates an authenticationRequest\\n\\n2. This authenticationRequest is sent to AuhtenticationManager\\n\\n3. The manager delegates the request to AuthenticationProviders which uses an UserDetailsService",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Authentication Architecture Recap",
        "Time in Clip": "0:11",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=4&mode=live&start=11&noteid=8578cb54-5270-4a00-ae06-378474d6e6e9",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "Every record has 3 parts:\\n1. Key - Anything\\n2. Value - Anything\\n3. Timestamp - Timestamp format",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Apache Kafka Application",
        "Clip": "Topics",
        "Time in Clip": "0:14",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=da300bcb-2b61-4801-a737-85371bfff2e4&clip=4&mode=live&start=14&noteid=c32bf618-5749-43f8-8820-e0502eb5d363",
        "Tags": [
            "#kafka",
            "#record"
        ]
    },
    {
        "Note": "IPVLAN. This is the same as MACVLAN that it allows to connect to existing n/w.\\n\\nThe main difference is that it doesn't give the containers their own MAC addresses.",
        "Course": "Docker Networking",
        "Module": "Use Cases and Drivers",
        "Clip": "Joining Existing Networks with the IPVLAN Driver",
        "Time in Clip": "0:22",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m2&clip=4&mode=live&start=22&noteid=0586daa1-9b43-4d28-8168-d6cde029f7b8",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Apache zookeeper keeps a consensus between the vast cluster of all the nodes. It maintains configuration information, health status etc",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Distributed Consensus with Apache Zookeeper",
        "Time in Clip": "0:56",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=4&mode=live&start=56&noteid=75211c9b-7eeb-48e9-957a-03785edb3aaa",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "SecurityContextHolder stores the SecurityContext and the AuthenticatedPrinciple once the request is generated.\\n\\nThis guy is thread local and the SecurityContext will be available in the current thread.",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Authentication Architecture Recap",
        "Time in Clip": "1:11",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=4&mode=live&start=71&noteid=8f24f912-395f-459a-8259-da23564abf9b",
        "Tags": [
            "#spring",
            "#security"
        ]
    },
    {
        "Note": "The work which the workers do are taking the message from producers, assign a topic to that message",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Distributed Consensus with Apache Zookeeper",
        "Time in Clip": "1:43",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=4&mode=live&start=103&noteid=110d5ce2-e952-4ea4-8f39-30fb943a7e09",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "Microservices should have a clearly defined public boundary. All ms have a boundary context inside which they operation.",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Components of a Microservice",
        "Time in Clip": "1:57",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=4&mode=live&start=117&noteid=de15f381-9cdc-471f-9ff4-515fe14a1d9c",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "One ms doesn't mean it will have only 1 service in it. There are be many things a ms is doing but as a whole is responsible for a part of the whole application. For eg: \\n- Service and DB\\n - Now here the service can be scaled out running on different hosts. The DB could have replication.\\n- There could a local cache involved\\n- There could be a cron job which listens to incoming mssgs",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Components of a Microservice",
        "Time in Clip": "1:57",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=4&mode=live&start=117&noteid=d1acb454-136e-41b0-8fc4-11e95c8fe723",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "In ms, there are many challenges to the observability of the entire service. For eg. When we want to take out some report on some aspect of the ms, we run into a problem of collating the data from different service which have their own data models. \\n\\nThis is known as a cross-database join problem.\\n\\n- So it becomes challenging to avoid making microservices into distributed monoliths.",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Challenges of Independent Governance",
        "Time in Clip": "3:33",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=4&mode=live&start=213&noteid=953ca0e8-a880-4f2c-9386-124253b8f5fe",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "It is pub-sub messaging system consisting of Producer/Consumer, Brokers/Cluster, Topics, Workers, Leaders, Controller.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Getting to Know Apache Kafka's Architecture",
        "Clip": "Distributed Consensus with Apache Zookeeper",
        "Time in Clip": "3:34",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m2&clip=4&mode=live&start=214&noteid=d6035697-3a15-4d1c-bb88-714aa3bb6021",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "UserDetailesService loadsTheUser",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Authentication Architecture Recap",
        "Time in Clip": "4:20",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=4&mode=live&start=260&noteid=85850be1-4fd0-40e8-85df-30b764130501",
        "Tags": null
    },
    {
        "Note": "Scopes -\\n1. compile - default scope,i.e, all the resources are available everywhere\\n2. provided - the artifact is going to be available throughout the entire build cycle. But its not going to be packaged in the end\\n3. runtime - not needed for compilation, but needed for execution. Ex- JDBC drivers\\n4. test - only available for the test phase\\n5. system - never use. hardcode a path to a jar on the system\\n6. import - deals with dependencyManagement sections",
        "Course": "Maven Fundamentals",
        "Module": "Maven Dependencies",
        "Clip": "Scopes",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m3&clip=5&mode=live&start=4.635596&noteid=f34c23e7-b13c-4e9b-959d-56bcac2c3cbb",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "Challenges\\n1. They are hard\\n2. Successful development needs more technical sophistication\\n3. Organizational investment is crucial in maintaining the architectural/responsibility boundaries in a ms.\\n4. Communications are slow as they happen over a n/w. So, we require proper transient failure management.\\n5. Security becomes more complex. Both under and over investment can lead to bad ms architecture\\n6. Require sophisticated operational capabilities: For eg, error analysis, Log tracing, Observability needs to happen properly over multiple sources of data. Also, automation is crucial to reduce time.\\n7. We should be aware to not turn the ms into distributed monoliths, i.e, pseudo ms which carry with them the complexities of monoliths but are distributed in ms bring out the worst of both worlds",
        "Course": "Microservices: Getting Started",
        "Module": "The Challenges of Microservices over Monoliths",
        "Clip": "Reviewing Challenges of Microservices",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=6aeec2dd-045e-48d5-b8cf-656af03824dd&clip=5&mode=live&start=7&noteid=c0725b73-5ddc-4533-8a3a-c1383962a591",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "assertAll takes in all the assertions of test class and tests all of them instead of short circuiting\\n",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing More Complex Tests ",
        "Clip": "Demo: Controlling Test Method Execution",
        "Time in Clip": "3:49",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=8f3dd63e-8e33-4fd3-a7c4-f4215fda7caf&clip=5&mode=live&start=229.053897&noteid=1270e09c-c911-4804-913e-b151eb8e50ea",
        "Tags": [
            "#java",
            "#junits"
        ]
    },
    {
        "Note": "We can also extract tests of same category into subclass with @Nested. \\nAlso, we can use @displayName which gives a more better understanding of the test scenarios which are tested.\\n",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Writing More Complex Tests ",
        "Clip": "Demo: Running Groups of Tests",
        "Time in Clip": "0:02",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=8f3dd63e-8e33-4fd3-a7c4-f4215fda7caf&clip=6&mode=live&start=2.20052&noteid=f24b317d-276f-4e0e-85b6-a0553e020d21",
        "Tags": [
            "#java",
            "#junits"
        ]
    },
    {
        "Note": "MS boundaries should be properly identified. Domain driven design.\\n- A MS should be around business boundaries.",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Identifying Microservice Boundaries",
        "Time in Clip": "1:26",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=6&mode=live&start=86&noteid=cebc27a5-f5dd-445d-9839-bc2201448205",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "MS boundary pitfalls\\n- MS boundaries should not be taken as noun into a microservice\\n - This will lead to normal CRUD microservices as if they are thin wrappers around databases\\n - Logic still remains distributed around places\\n- There should not be cyclic dependency\\n- There should not be chatty n/w\\n",
        "Course": "Microservices Fundamentals",
        "Module": "Architecting Microservices",
        "Clip": "Identifying Microservice Boundaries",
        "Time in Clip": "3:19",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=9816dbf0-2e36-446b-9d95-1385da378af9&clip=6&mode=live&start=199&noteid=4c67cb83-1caf-4bc2-9617-f3a6d4eab5be",
        "Tags": [
            "#ms"
        ]
    },
    {
        "Note": "A kafka consumer is a pull mechanism, i.e the consumer will pull the new messages in cluster and process it\\n\\n",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Apache Kafka Application",
        "Clip": "Kafka Consumer",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=da300bcb-2b61-4801-a737-85371bfff2e4&clip=7&mode=live&start=7&noteid=64f93544-99f2-4ffd-ab2d-69cc206cbefd",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "Realm is a security policy domain and it can be added to the request.\\n\\nThis separates the security policies for the application",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Configuring Digest Authentication",
        "Time in Clip": "0:58",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=7&mode=live&start=58&noteid=38dc6471-503a-46b8-b2f9-6d3bc9496036",
        "Tags": null
    },
    {
        "Note": "By default the filter chain matcher is any",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Configuring Digest Authentication",
        "Time in Clip": "3:58",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=7&mode=live&start=238&noteid=3ce4af33-cb7d-4137-8ce6-d548f17b6216",
        "Tags": null
    },
    {
        "Note": "If there are more than one filters, we need to assign an order which the spring will authenticate in that order",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Diving Under the Hood of Spring Security Authentication",
        "Clip": "Configuring Digest Authentication",
        "Time in Clip": "4:23",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=68ba7d48-af6c-4cd8-8c1e-ec903c61481e&clip=7&mode=live&start=263&noteid=4fa08397-03ce-40b9-bc0c-77205bd9f406",
        "Tags": null
    },
    {
        "Note": "Multiple consumers are part of a consumer groups, then the consumers will act as a single entity by distributing the messages among them",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Apache Kafka Application",
        "Clip": "Demo: Kafka Consumer",
        "Time in Clip": "1:14",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=da300bcb-2b61-4801-a737-85371bfff2e4&clip=8&mode=live&start=74&noteid=f6ffc450-cc7f-48e7-96c6-8ad32b562898",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "If there are 2 entities and we want them to be independent of each other, then we add a bridge by composition with the interface in the abstract class.",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Bridge Design Pattern",
        "Clip": "Demo: Shape With a Bridge",
        "Time in Clip": "4:35",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m3&clip=8&mode=live&start=275.996754&noteid=8267f311-04e8-4f09-9394-817008ce2f86",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#bridgePattern"
        ]
    },
    {
        "Note": "Best for creating objects which are immutable.",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Builder Pattern",
        "Clip": "Demo: Builder",
        "Time in Clip": "6:35",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m3-builder&clip=8&mode=live&start=395.747794&noteid=74dac8b6-f1fd-4c7c-870a-f3117d1fa88c",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#builderDesignPattern"
        ]
    },
    {
        "Note": "False sharing happens bcz of caches at different levels with same variable in multiple caches",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Ordering Read and Writes Operations on a Multicore CPU",
        "Clip": "Understanding False Sharing on Multicore CPUs",
        "Time in Clip": "0:20",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m3&clip=9&mode=live&start=20.784525&noteid=e5874f61-523c-4b96-b9a4-af1262bd7944",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "False sharing happends bcz the caches are stores in lines and when each lines has multiple variales and any of them is marked dirty then it leads to false sharing",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Ordering Read and Writes Operations on a Multicore CPU",
        "Clip": "How False Sharing Can Impact the Performance of Applications",
        "Time in Clip": "1:26",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m3&clip=10&mode=live&start=86.895962&noteid=bacf3921-bacb-4c3d-ab96-6f8098e64659",
        "Tags": [
            "#java",
            "#concurrency"
        ]
    },
    {
        "Note": "The composition with interface in abstract class can be changed the next time and the abstract class concreate implementations would not even know about the formatter.",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Bridge Design Pattern",
        "Clip": "Demo: Movie Printer HTML Bridge",
        "Time in Clip": "1:59",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m3&clip=10&mode=live&start=119.618272&noteid=723b31cf-f60b-4271-a2ff-1fcc2c1c53f0",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#bridgePattern"
        ]
    },
    {
        "Note": "\\nUML -\\nInterface  composition  AbstractClass(m)\\nRefinedImpl                  Concreate class",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Bridge Design Pattern",
        "Clip": "Demo: Movie Printer HTML Bridge",
        "Time in Clip": "1:59",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m3&clip=10&mode=live&start=119.618272&noteid=11c57a18-39bb-45ee-99b9-75bf49347b61",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#bridgePattern"
        ]
    },
    {
        "Note": "Has complex constructors",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Builder Pattern",
        "Clip": "Summary",
        "Time in Clip": "0:58",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m3-builder&clip=11&mode=live&start=58.027&noteid=9a7e9dc8-4160-499a-ab51-35c0f1631ce5",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#builderDesignPattern"
        ]
    },
    {
        "Note": "\\nDesign for uncertainity\\nCan be complex\\nProvides flexibility\\nmore than composition",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Bridge Design Pattern",
        "Clip": "Summary",
        "Time in Clip": "0:45",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m3&clip=13&mode=live&start=45.093026&noteid=00927a7e-c4fd-43f1-9b6d-b70b80238975",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#bridgePattern"
        ]
    },
    {
        "Note": "Synchronous Communication Architectures: \\nRPC(Remote procedure calls) styled communications. The RPC styled communication often occurs b/w client and servers\\nEg - \\n1. HTTP Traffic\\n2. SQL queries\\n3. SOAP \\nSo, they are equivalent to function call on a system.",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Introduction to RPC",
        "Time in Clip": "0:19",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=0&mode=live&start=19&noteid=462ff745-217b-4175-b050-44b2722259a4",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "8s It is orchestrator of micro-services apps. Nowadays it is also thought of as the OS of cloud",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Big Picture View",
        "Time in Clip": "0:08",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=1&mode=live&start=8&noteid=2e33b613-39f3-4a4d-97a3-f2f6bf9212e1",
        "Tags": [
            "#k"
        ]
    },
    {
        "Note": "Cache-Control header tells the browser regarding the  to disable all caching\\n\\nAs cache pages are stored in the browsers temp files",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "Out-of-the-Box Security Protection",
        "Time in Clip": "0:13",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=1&mode=live&start=13&noteid=4050ebef-87e0-4d19-87f5-8d26afb004a8",
        "Tags": null
    },
    {
        "Note": "\\n- Topics are named feed or category of messages\\n- It is a logical entity.\\n- Kafka keeps a log file for each topic",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Topics in Detail",
        "Time in Clip": "0:23",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=1&mode=live&start=23&noteid=fa54258e-7674-40d5-868d-735b4ca648e5",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "X-Content-Type-Options:nosniff header\\n\\nThis tells the browser to not identify the content types of the request\\n\\nSince this can lead to polygot files which actually look like some format but are executed as scripts on the browser",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "Out-of-the-Box Security Protection",
        "Time in Clip": "0:42",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=1&mode=live&start=42&noteid=b59acfa9-9f63-43db-a8f0-7320990c39c4",
        "Tags": null
    },
    {
        "Note": "\\n1. Components represent part of whole structure.\\n2. Compose objects into tree structures.\\n3. Same operations applied on individual and composites.\\n",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Composite Pattern",
        "Clip": "Concepts",
        "Time in Clip": "0:45",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m4&clip=1&mode=live&start=45.275889&noteid=64f82665-403c-4674-834d-9a3d8c79cadf",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#compositePattern"
        ]
    },
    {
        "Note": "doesnt use new keyword. Uses clone() from the first protoype of object.\\n",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Prototype Pattern",
        "Clip": "Concepts",
        "Time in Clip": "0:54",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m4-prototype&clip=1&mode=live&start=54.830239&noteid=c9142702-8ee7-4d7a-80f6-8e3090ca4472",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#prototypeDesignPattern"
        ]
    },
    {
        "Note": "Serialization is process of converting an object state or data structures to some format which can be transmitted through n/w and then again can be reformed to the original state.\\n\\n",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "Serialization Formats",
        "Time in Clip": "1:07",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=1&mode=live&start=67&noteid=abbeeb47-0c73-4116-8749-126a7d9be633",
        "Tags": [
            "#kafka",
            "#serialization"
        ]
    },
    {
        "Note": "X-Frame-Options: DENY\\n\\nIndicates that the browser should be allowed the page to be rendered in a frame, iframe or object",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "Out-of-the-Box Security Protection",
        "Time in Clip": "1:15",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=1&mode=live&start=75&noteid=9bad82da-dcf9-4f42-8932-fb22757496c3",
        "Tags": null
    },
    {
        "Note": "Service discovery: This means that the network address of a service is located dynamically in a ms. This is not a new concept and is present from many days. For eg: DNS.\\n\\nThere are another sevices for service discovery like Apache Zookeeper - \\nSo, if you require -\\nCluster management\\nHadoop Kafka\\nMassive scalability\\nCustomizable clustering, redundancy\\nHigh performance \\n\\nBut this all comes with some complexity\\n",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Service Discovery",
        "Time in Clip": "1:20",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=1&mode=live&start=80&noteid=57065267-4a7e-4c0c-9bc8-3c00c48569c1",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "\\n- When producer sends a message to kafka topic, the messages are appended in a time series and are immutable. \\n- Once they are pushed to the topic, it cannot be changed.\\n- In case there is an incorrect message in the topics, it needs to be corrected using a new message and the previous message cannot be changed.\\n- It is the job of the consumer to reconcile the message after consuming it.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Topics in Detail",
        "Time in Clip": "1:34",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=1&mode=live&start=94&noteid=d1bd1f4e-92b1-4f8f-b711-e97baf26ce5c",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "X-XSS-Protection: Reflective XSS",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "Out-of-the-Box Security Protection",
        "Time in Clip": "2:07",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=1&mode=live&start=127&noteid=aa5e545a-0482-4827-8b43-a20e13f363d5",
        "Tags": null
    },
    {
        "Note": "Topics are abstractions. All the producers and consumers just know the topic and don't care where is it in Kafka cluster",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Topics in Detail",
        "Time in Clip": "2:15",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=1&mode=live&start=135&noteid=aead9b15-de7e-407d-831f-4dbeb09c132c",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "Every container gets a DNS resolver which listens on 127.0.1.11:53. All the DNS requests are sent to this port.\\n- Once it get the request it sends the request to a DNS service onto the local docker host machine. \\n- If we still can't get the IP of the service it is then brodcasted to the upper layers\\n- Ofcourse, this only works when the services are on the same network\\n- Every service gets its own virtual IP(VIP) and this stays with the services for its entire life\\n- Then the requests are load balanced to internal tasks",
        "Course": "Docker Networking",
        "Module": "Network Services",
        "Clip": "Service Discovery",
        "Time in Clip": "2:16",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m3&clip=1&mode=live&start=136&noteid=6962a753-710b-4e64-b0e6-a8a4b2c51b25",
        "Tags": [
            "#docker",
            "#netwwork"
        ]
    },
    {
        "Note": "There are serialization format which can be used for transferring data since binary serialization is not human readable.\\n\\nAVRO is an serialization format which Kafka has developed for compact binary serialization",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "Serialization Formats",
        "Time in Clip": "2:20",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=1&mode=live&start=140&noteid=e43d81f6-f14a-4b71-a996-e65919b204e0",
        "Tags": [
            "#kafka",
            "#serrialization"
        ]
    },
    {
        "Note": "This style of maintaining the messages in a sequence of time-ordered, immutable events is an architectural style known as *event sourcing*",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Topics in Detail",
        "Time in Clip": "2:25",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=1&mode=live&start=145&noteid=a90df0d3-c998-4a88-a135-2d7f4cfcf56b",
        "Tags": [
            "#kafka"
        ]
    },
    {
        "Note": "CSRF protection",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "Out-of-the-Box Security Protection",
        "Time in Clip": "2:27",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=1&mode=live&start=147&noteid=2c2701f7-8d4d-4bd2-b3b0-1aaa25aeff00",
        "Tags": null
    },
    {
        "Note": "At high level: \\n- Each mssg has a timestamp when the message is received by a kafka broker. Also it gets an unique identifier. \\n- The combination of timestamp and identifier forms it's placement in the topic.\\n- Also it contains the payload in binary",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Topics in Detail",
        "Time in Clip": "2:56",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=1&mode=live&start=176&noteid=c4394cd1-ef43-438e-b22e-c260ba8765b8",
        "Tags": [
            "#kafka",
            "#message"
        ]
    },
    {
        "Note": "8s There are masters and nodes in a cluster\\n- Masters is the control plane. \\n- Nodes do the actual work and report back to master",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Big Picture View",
        "Time in Clip": "3:10",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=1&mode=live&start=190&noteid=59acf68f-46d8-404d-bbcd-35ce073c2977",
        "Tags": [
            "#k"
        ]
    },
    {
        "Note": "The schema registry is maintained per topic and also replicated in the Kafka cluster to avoid data failures",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "Serialization Formats",
        "Time in Clip": "4:13",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=1&mode=live&start=253&noteid=4fb0b57f-19c4-4b37-ae96-65afa868b75b",
        "Tags": [
            "#kafka",
            "#serialization"
        ]
    },
    {
        "Note": "\\n- Kafka enables the consumers to consumer the messages from the topic independently. \\n- There are can be any number of consumers who listen to a topic.\\n- Each consumer must maintain its own state of the consumption state and should not affect other consumers.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Topics in Detail",
        "Time in Clip": "4:21",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=1&mode=live&start=261&noteid=0866c0d2-5526-486c-bc05-6e3f2143f8d0",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "8s K8s takes applications and wrap it in a Pod.",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Big Picture View",
        "Time in Clip": "4:27",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=1&mode=live&start=267&noteid=5a06d939-e64c-485a-b378-6288b14fbc92",
        "Tags": [
            "#k"
        ]
    },
    {
        "Note": "8s  \\n- Multi-master control plane has a master nodes. \\n- They should be run in different failure domain reason. \\n- Also, it is better to be connected with reliable n/w\\n- All the masters run something called as control plane service",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Masters",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=2&mode=live&start=0&noteid=5083e57f-fe96-4db9-b01c-1a6f00d04dc9",
        "Tags": [
            "#k",
            "#masters"
        ]
    },
    {
        "Note": "Routing Mesh: Routing and load balancing incoming connections operation on the Layer 4(Transport layer) \\n- So, all request coming from the outside world are routed using the routing mesh",
        "Course": "Docker Networking",
        "Module": "Network Services",
        "Clip": "The Routing Mesh",
        "Time in Clip": "0:02",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m3&clip=2&mode=live&start=2&noteid=efbe2abd-34b6-4932-a1bc-af3c53754f0d",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "AVRO\\n- Binary serialization format. \\n- So, it is light weight. \\n- JSON based schema to define structure which is present in the container\\n- .avsc file format\\n- JSON schema\\n\\nFor eg: User object -> User_schema\\n{\\n\"type\": \"record\",\\n\"namespace:\"com.pluralsight\",\\n\"name\":\"User\",\\n\"fields\": [\\n\"\"...\\n]",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "AVRO",
        "Time in Clip": "0:03",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=2&mode=live&start=3&noteid=1c8b203e-feef-418e-a8b6-c8747e9de0d3",
        "Tags": [
            "#kafka",
            "#serialization"
        ]
    },
    {
        "Note": "How consumers maintain autonomy with so many consumers consuming from the message:\\n- Message Offset: It is a placeholder.  \\n - So, it can be visualized as a bookmark in a book stating the last read message position.\\n - The offset is maintained by the Kafka consumer since it is the job of the consumer to consume the messages.\\n - The offset corresponds to a **message identifier** present in each message.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "The Consumer Offset and Message Retention Policy",
        "Time in Clip": "0:05",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=2&mode=live&start=5&noteid=8a7c24f2-eae7-456e-b32f-677efb1154c7",
        "Tags": [
            "#kafka",
            "#message"
        ]
    },
    {
        "Note": "\\n1. Tree structured.\\n2. Root is a component\\n3. Leaf or composite have same operations.\\n4. Composite knows about child objects",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Composite Pattern",
        "Clip": "Design Considerations",
        "Time in Clip": "0:15",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m4&clip=2&mode=live&start=15.485137&noteid=cec4a38d-3dd2-49a6-9629-35ac8ab73d1d",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#compositePattern"
        ]
    },
    {
        "Note": "***How the consumer keeps track of the offset***:\\n- The consumer keeps track of the messages which have been read and not read and is entirely upto the consumer.\\n- It first establishes a connection with the broker. And then read the corresponding message.\\n- If the consumer has read any message, then it knows which was the last read message and it is entirely upto the consumer to: \\n - re read a message by going back\\n - advance its position to move forward\\n - stay put\\n- When a new message arrives, the connected consumer receives a notification for a new message and then it can update the offset of the last read message.**\\n\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "The Consumer Offset and Message Retention Policy",
        "Time in Clip": "1:07",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=2&mode=live&start=67&noteid=978c26e3-7b18-4498-b658-53a933c38716",
        "Tags": [
            "#kafka",
            "#message",
            "#consumer"
        ]
    },
    {
        "Note": "Message retention policy: \\n- All messages are retained by kafka regardless of the number of consumers which have read the message. \\n- This is defined on per-topic basis.\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "The Consumer Offset and Message Retention Policy",
        "Time in Clip": "2:41",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=2&mode=live&start=161&noteid=124de01c-cdd8-4fe5-9e1c-14e48784ea34",
        "Tags": [
            "#kafka",
            "#message"
        ]
    },
    {
        "Note": "AVRO schema types\\n- null\\n- boolean\\n- int\\n- longs... so basically primitive types\\n\\nComplex types\\n- records --- Complex data object\\n- enums - {\"symbols\": [\"BULE\", \"COLOR\"]}\\n- Map\\n- etc..",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "AVRO",
        "Time in Clip": "3:09",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=2&mode=live&start=189&noteid=193c511d-a5e2-4905-b215-9c6eaacf7003",
        "Tags": [
            "#kafka",
            "#serialization"
        ]
    },
    {
        "Note": "When we init swarm mode, ingress network is created by default and is available to all the nodes in the swarm. So, if any request comes to the swarm and is sent to the service which is not running a task for it - \\n- The ingress network exposes the port of the service that means all the nodes have exposed that port even if they are not running the tasks.\\n- Then when it comes to the VIP of the node which is not running the task, it sends the request to appropriate service by service discovery",
        "Course": "Docker Networking",
        "Module": "Network Services",
        "Clip": "The Routing Mesh",
        "Time in Clip": "3:14",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m3&clip=2&mode=live&start=194&noteid=7a950045-f79d-4777-9d3e-94fb8b8a4c19",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Service discovery is important part of a ms to avoid coupling b/w services.\\nSo, it maintains independence b/w services and this is essential for any ms.\\nMore complex service discovery solutions are available apart from DNS like zookeeper",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Stateless and Stateful RPCs",
        "Time in Clip": "3:42",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=2&mode=live&start=222&noteid=1d709b32-5d03-4860-9886-1ff37eab6f21",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Containers have a containerized collection of OS namespaces. The linux namespaces are - processes, Filesystem, network, Users, etc. So, a container is a collection of all these things.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "Kernel Internals",
        "Time in Clip": "3:54",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=2&mode=live&start=234&noteid=a0395b0c-f380-4c4a-9bc6-f049ae83bead",
        "Tags": [
            "#docker",
            "#architecture"
        ]
    },
    {
        "Note": "All the namespaces for each container are isolated. So, each container will have its own pid, filesystem, network, ipc(traffic)",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "Kernel Internals",
        "Time in Clip": "4:55",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=2&mode=live&start=295&noteid=2a5c9cc3-249f-4033-94c2-a208b47cb0b3",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "Idempotence helps prevent the introduction of erroneous data bcz of duplicate requests.\\n- Reduces the risk of coupling\\n- Simplifies client implementations",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Stateless and Stateful RPCs",
        "Time in Clip": "5:01",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=2&mode=live&start=301&noteid=b0c2e7e7-0153-432d-849f-b8cd5445e12c",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "In swarm mode, the ingress overlay n/w has a container  running on it named ingress-endpoint and is a system container.\\n- This container is present on all the nodes in the swarm\\n- This container is used to load-balance and discover the services\\n- **Every time any service is loaded by exposing a port it is by default also published onto the ingress network. And this is how we can discover the service and load balance it.**",
        "Course": "Docker Networking",
        "Module": "Network Services",
        "Clip": "The Routing Mesh",
        "Time in Clip": "6:03",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m3&clip=2&mode=live&start=363&noteid=c25f2130-7298-45d9-97c7-3d5b4c3678de",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "There can be some containers who use chew onto resources and starve others. So, we have control groups for that. In Linux, they are called cgroups.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "Kernel Internals",
        "Time in Clip": "6:18",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=2&mode=live&start=378&noteid=035fa45c-312d-4ff3-9746-f1f0bb8f94fe",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "8s -apiserver\\n- kube-apiserver is the front-end to the control plane. All the requests coming in are coming from here.\\n- Even the nodes communicate through here\\n- Exposes the REST API as well consuming JSON/YAML",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Masters",
        "Time in Clip": "6:33",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=2&mode=live&start=393&noteid=002c9cd9-e855-46ea-a578-5f64955092b2",
        "Tags": [
            "#k",
            "#kube"
        ]
    },
    {
        "Note": "cgroups enforces limit onto the resources.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "Kernel Internals",
        "Time in Clip": "6:39",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=2&mode=live&start=399&noteid=6d28bbd2-51fd-4d53-95f9-3f474e9cf8a6",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "\\n- Network partition: When there are different services on either side in a n/w call which think that the request was successful or failure on either side of n/w issues.\\n- Idempotency: So, in case of n/w partitioned, the client should have a fallback mechanism in place to handle failures. So, there can be a retry mechanism on each side. \\nBut how does the service will handle a retry message?\\n- So, the service should understand that it is a duplicate request and it already has the data required to process the request. The ability to not change the state of the system when the operation is performed multiple times is called \"Idempotence\".",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Stateless and Stateful RPCs",
        "Time in Clip": "6:54",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=2&mode=live&start=414&noteid=a9fe18c5-e088-4f1e-88d7-f64782475b99",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "8s -store\\n- Cluster Store is the only persistence store and config\\n- Based on etcd NpSQL DB\\n- This can also be placed in a highly available server",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Masters",
        "Time in Clip": "6:58",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=2&mode=live&start=418&noteid=59f72b05-b498-4ded-8de6-6045584d7cbc",
        "Tags": [
            "#k",
            "#cluster"
        ]
    },
    {
        "Note": "Be suspicious of another RPC calls which happen inside another if statements",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Stateless and Stateful RPCs",
        "Time in Clip": "7:19",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=2&mode=live&start=439&noteid=90e7518a-9df7-4e62-b006-7ecc7650f9af",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Example - \\n1. Chat service: responsible for managing chat messages\\n2. Notification service: responsible for notifying about a new chat.\\n\\n- Success scenario: A new chat message is sent by 1 person to another. The chat service stores the chat and calls the notification server to send out the notification.\\n- Failure scenario: In the case of synchronous messaging, there should be a failure mode which should be kept in mind. So, we need to give priority to the service whose success is more important. For ex; If the notification service fails to store the notification, the chat service should store it as that is more important. The failure can also happen in case of a n/w partition. So, we need to have failure/fallback mechanisms to properly handle errors.",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Stateless and Stateful RPCs",
        "Time in Clip": "7:37",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=2&mode=live&start=457&noteid=d4338b95-32b1-4e7e-b18b-93edc088085d",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "8s -controller-manager\\n- Controller of controllers: This is the controller for controlling different components in k8s\\n - Node controller\\n - Deployment controller\\n - Endpoints/EndpointSliceController, etc\\n- Each controller runs in a reconciliation loop to have a check on the things it is responsible for",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Masters",
        "Time in Clip": "8:27",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=2&mode=live&start=507&noteid=3690988d-5e08-4ad9-8ce5-f4caa414887c",
        "Tags": [
            "#k",
            "#Kube"
        ]
    },
    {
        "Note": "8s -scheduler\\n- Watches the API server for new work tasks\\n- Assigns work to cluster nodes\\n",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Masters",
        "Time in Clip": "9:17",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=2&mode=live&start=557&noteid=de878ef1-4dbd-4096-8538-d582e5187feb",
        "Tags": [
            "#k",
            "#Kube"
        ]
    },
    {
        "Note": "Coordination of Stateful Synchronous RPCs:\\n1. All-or-nothing behavior is impossible\\n2. Choose a failure mode\\n3. Distributed transactions - The coordination of multiple state changes that may or may not occur across services is called distributed transactions",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Stateless and Stateful RPCs",
        "Time in Clip": "9:49",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=2&mode=live&start=589&noteid=94ad5a7f-a1c8-48a9-af9d-e4d52d7141ea",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "HTTP Routing Mesh(HRM) - Application layer(Layer 7) network routing. \\n- Why HRM?\\n - In Layer 4 routing, different services cannot listen on same port\\n - So, HRM works on Layer 7 protocol ad this Layer 4 doesn't have the knowledge of the layers upwards\\n- HRM allows -\\n - Allows multiple services on the same port\\n - Operates at the application layer \\n - Also this requires Docker Datacenter\\n",
        "Course": "Docker Networking",
        "Module": "Network Services",
        "Clip": "The HTTP Routing Mesh",
        "Time in Clip": "0:03",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m3&clip=3&mode=live&start=3&noteid=dbd60bc2-aaeb-4c63-b4bc-89384587e7b7",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Its the center of docker and exposes apis to use from cli to connect to resources and outputs containers.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "The Docker Engine",
        "Time in Clip": "0:06",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=3&mode=live&start=6&noteid=bbab1137-8627-4eea-ab7a-f90e5b3b6abc",
        "Tags": [
            "#docker",
            "#dokerengine"
        ]
    },
    {
        "Note": "8s  \\n- **Kubelet**\\n - Kubelet is the main K8s agent working on each and every node\\n - registers node with cluster\\n - Kublet watches the API server for work tasks(Pods)\\n - Execute Pods\\n - Report back to masters\\n- **Container runtime**\\n - K8s doesn't know how to run containers and other things. Hence it uses Container runtime for that. For eg - Docker, containerd\\n - Also the runtime is pluggable using Container Runtime Interface(CRI)\\n- **Kube-proxy**\\n - Networking component\\n - Pod IP addresses. All the containers inside a Pod get the same IP\\n - Does lightweight load balancing b/w pods",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Nodes",
        "Time in Clip": "0:20",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=3&mode=live&start=20&noteid=f91d748e-6a4b-4537-b906-96f4280cea66",
        "Tags": [
            "#k",
            "#Node",
            "#Kubelet"
        ]
    },
    {
        "Note": "For kafka to work, we need to run the main components of Kafka.\\n\\nFirst kafka zookeeper is started using - bin/zookeeper-server-start.sh config/zookeeper.properties",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Demo: Starting Apache Kafka and Producing and Consuming Messages",
        "Time in Clip": "0:37",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=3&mode=live&start=37&noteid=499f4b70-22c4-45bf-a00f-de019d41e0a8",
        "Tags": [
            "#kafka",
            "#cluster"
        ]
    },
    {
        "Note": "There are 2ways to make a code testable with problem of dependency and mixed concerns:\\n1. Extraction of code which we want to test into some method, class\\n2. Dependency - Provide a test double to the target class which we want to test which will remove all the external side effects by execution of dependency code.",
        "Course": "Getting Started Unit Testing with JUnit 5",
        "Module": "Making Existing Code Testable ",
        "Clip": "Understanding Dependencies",
        "Time in Clip": "1:15",
        "URL": "https://app.pluralsight.com/player?course=junit-5-unit-testing-getting-started&author=jim-weaver&name=2e12dcbe-0852-467e-aa22-8a4d0c15aa0c&clip=3&mode=live&start=75.180373&noteid=2e935cba-340f-4dfb-a286-9c47b5ad1757",
        "Tags": [
            "#java",
            "#junits"
        ]
    },
    {
        "Note": "SSL Secure Socket Layer - a predecessor of TLS",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "HTTPS for Everything",
        "Time in Clip": "1:18",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=3&mode=live&start=78&noteid=2de8903d-b406-46fb-b51f-6fe80eab387d",
        "Tags": null
    },
    {
        "Note": "TLS stands for Transport Layer Security which is the official protocol used to encrypt HTTPS",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "HTTPS for Everything",
        "Time in Clip": "1:21",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=3&mode=live&start=81&noteid=d9ef9ef9-1111-461f-b693-f028fc27660e",
        "Tags": null
    },
    {
        "Note": "While creating a topic, kafka needs a zookeeper instance. Bcz there can be multiple zookeepers each managing their own cluster for that topic.\\n\\nIt is the zookeeper who is responsible for assigning the topic to a broker.\\n\\n1. First zookeeper scans the broker registry to select a broker for assigning the topic.\\n2. Then a new log directory created in the cluster\\n\\n\\n\\n\\n\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Demo: Starting Apache Kafka and Producing and Consuming Messages",
        "Time in Clip": "4:14",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=3&mode=live&start=254&noteid=23b74e09-0046-4d9f-9f97-087b3aeb15df",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "HRM takes the headers in the requests at Layer 7 maps the requests to each services\\n- There is a **ucp-hrm** service which does all the job. So, all the requests first come to this service and then it balances it out to particular services based in the headers",
        "Course": "Docker Networking",
        "Module": "Network Services",
        "Clip": "The HTTP Routing Mesh",
        "Time in Clip": "4:27",
        "URL": "https://app.pluralsight.com/player?course=docker-networking&author=nigel-poulton&name=docker-networking-m3&clip=3&mode=live&start=267&noteid=bd7f96d6-b615-4c4e-b2a5-34a1d74e6b48",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Creation of topic:\\n- When the topic is created, the zookeeper scans its registry to assign the topic to some available broker based on the metadata maintained by him.\\n- Then a leader is chosen to take the ownership of the topic. \\n- Based on the replication-factor option, multiple brokers are bought into consensus to take care of the topic.\\n- Log files are created in the broker machine. These files are the physical representation of the topic.\\n- Each broker creates a log based on the topic and partition it represents.\\n- Each broker keeps a subset of metadata present with the ZK particularly the mapping of which broker is managing which topic/partition. Also, each broker knows the leader of each topic.\\n- This enables the broker to know which broker is managing which topic and the request to persist a message is transferred appropriate broker. \\n- All these metadata is sent to the producer to enable him to send the messagse",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Demo: Starting Apache Kafka and Producing and Consuming Messages",
        "Time in Clip": "5:07",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=3&mode=live&start=307&noteid=1a603161-963c-41fa-93f9-6e143d6adfda",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "Docker client(cli) calls the daemon using REST API to start the container. The daemon internally calls containerd using GRPC call internally to strart the container. But even containerd doesn't know how to handle the namespaces and cgroups of the OS. Hence, OCI layer comes into picture(runc in linux) and provides an implementation for using the namespaces and cgroups.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "The Docker Engine",
        "Time in Clip": "11:01",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=3&mode=live&start=661&noteid=be84f9ad-04b0-4d67-9c2c-18c819cda6b5",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "The OCI layer can be replaced with any runtime and used independently with docker daemon. This decouples the entire process and can be used to restart the docker-engine even when the containers are up and running.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "The Docker Engine",
        "Time in Clip": "11:01",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=3&mode=live&start=661&noteid=68f45b5a-c261-41d7-9ecb-e94ed5c603f6",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "Containerd has all the logic for implementing things like - Basic networking, storage, image distribution, etc.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "The Docker Engine",
        "Time in Clip": "11:14",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=3&mode=live&start=674&noteid=36d49bd8-98f7-4332-8b4d-7194f3ebaf2a",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "runc is not a long-lived process and is just used to get the container up and ready and then it stops connecting the container with a shim process. Containerd is the main daemon running with one-to-many mapping b/w shim processes.",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "The Docker Engine",
        "Time in Clip": "12:13",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=3&mode=live&start=733&noteid=53ed249f-404d-48ac-8aac-3c6192aff723",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "8s \\n- **Declarative model** : describes what you want(desired state) in a manifest file to api server.\\n - Then k8s will do everything for you",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "The Declarative Model and Desired State",
        "Time in Clip": "0:13",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=4&mode=live&start=13&noteid=a3fcf1c4-3218-4a19-8f21-29d3e159d5ce",
        "Tags": [
            "#k"
        ]
    },
    {
        "Note": "Synchronous communications:\\n1. Service Discovery: Without service discoveries, we would have to orchestrate the deployments\\n2. Stateless RPCs: Simple, Functional or Conduit types\\n3. Stateful RPCs: It is important to have Idempotence b/w services in case of states. Distributed transactions: Which have failure modes. So, we need to be aware of failures and proper mechanisms in case of failures to maintain the overall state of the transaction in the system. \\n4. Availability & Latency: Sync will add latency. So, sync styles work best when you have fast and quick responses b/w services",
        "Course": "Microservices: Getting Started",
        "Module": "Synchronous Communication Architectures",
        "Clip": "Review",
        "Time in Clip": "0:35",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=39bcba8d-87ae-4d20-8f53-949576c96a93&clip=4&mode=live&start=35&noteid=d271cf5e-0f42-436b-a8e5-689c3220afad",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Schema registry is used to handle the distribution of schemas. It also uses a kafka topic to achieve that.\\n\\n- Subject Name Strategy:\\n - We should have a schema for each messages in a particular topic to have proper segregation of messages.\\n - Subject will be the <topic-name>-key in the messages",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "Schema Registry",
        "Time in Clip": "0:57",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=4&mode=live&start=57&noteid=6f66a71e-5773-4fd9-953f-8e24b656d916",
        "Tags": [
            "#kafka",
            "#serialization"
        ]
    },
    {
        "Note": "\\n- Commit logs are the source of truth for all the messages. Log entries are physically stored and maintained on the system.\\n- Once we have these logs, many data structures can be derived from them.\\n- This helps in replication, redundancy of the messages\\n\\n***So Apache Kafka is publish-subscribe messaging rethought as a distributed commit log***",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka as a Distributed Commit Log",
        "Time in Clip": "0:58",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=4&mode=live&start=58&noteid=778271eb-ddaf-47cd-8a56-5935503471c7",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "With cgroups and namespaces, we have a union file system and registry. AUFS in linux. NTFS in Windows",
        "Course": "Docker Deep Dive",
        "Module": "Architecture and Theory",
        "Clip": "Windows Containers",
        "Time in Clip": "0:59",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=3f486267-c447-4782-9a70-f7c1d4de536a&clip=4&mode=live&start=59&noteid=a0451f33-c450-496f-930d-445f8b0729f7",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "The clone() method of clonables returns only shallow copy. The protoype of the objects mostly requires deep clones. Hence, protoype are implemented with a registry which is cloned.",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Prototype Pattern",
        "Clip": "Demo: Statement",
        "Time in Clip": "2:58",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m4-prototype&clip=4&mode=live&start=178.321042&noteid=5fb42dff-7a23-4fa8-9fa8-c60909b504b8",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#prototypeDesignPattern"
        ]
    },
    {
        "Note": "When we use some AVRO schema present in some schema registry, and use it for serailization, an ID is appended to the binary data as schema identifier for consumer to know which schema is used.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "Schema Registry",
        "Time in Clip": "3:31",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=4&mode=live&start=211&noteid=f6f57aa3-b43d-4459-b71d-ff5db30e08b4",
        "Tags": [
            "#kafka",
            "#serialization",
            "#schema"
        ]
    },
    {
        "Note": "8s  \\n- Every container run inside a pod. And k8s can only work with pod. \\n- Each pod has a shared execution environment. \\n- If 2 containers run in a pod, the exec env is shared among both of them.\\n- All the containers in same pod get same IP. They should be mapped with ports.\\n- **Scaling in k8s is scaling the pods**\\n- **Pod deployment is an atomic operation.** So, a pod is up only when all the containers in the pod are up and running.\\n- Pod lifecycle is Pending, running, succeed. Pod can never come back/heal. When any pod is down, a similar pod is bought up but not the previous one\\n- Pods provide a lot of administrative data to k8s like -\\n - Labels, Policies, resources, co-scheduling containers",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Pods",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=5&mode=live&start=0&noteid=be550334-fd20-4e1d-9e07-529db79731f1",
        "Tags": [
            "#k",
            "#pod"
        ]
    },
    {
        "Note": "\\n- Each topic(logical unit) has one or more partitions.\\n- Each partition is maintained by one or more brokers\\n- The partition determines the efficiency and throughput of a partition\\n- **Each partition must fit entirely on one machine**\\n- So, when we have large partitions on a single machine then we would be constrained to only on one broker managing that topic",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Partitions in Detail",
        "Time in Clip": "0:05",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=5&mode=live&start=5&noteid=40e0b7ac-062c-400a-870d-b95084993c30",
        "Tags": [
            "#kafka",
            "#topic",
            "#partition"
        ]
    },
    {
        "Note": "\\nExample - Collections API interfaces",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Composite Pattern",
        "Clip": "Demo: Map",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m4&clip=5&mode=live&start=7.178828&noteid=67a54778-7780-46d6-a5d3-f74d659d3325",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#compositePattern"
        ]
    },
    {
        "Note": "\\n- Kafka is what it is because of its partitions i.e to be fault tolerant, scale and achieve higher levels of throughput.\\n- Each partition can be managed by one or more brokers",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Partitions in Detail",
        "Time in Clip": "1:02",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=5&mode=live&start=62&noteid=67f9b996-b169-45b6-8b68-eba4d7bf6fef",
        "Tags": [
            "#kafka",
            "#topic",
            "#partition"
        ]
    },
    {
        "Note": "Lets Encrypt",
        "Course": "Spring Security: Authentication / Authorization - Building Effective Layers of Defense",
        "Module": "Dealing with Common Security Threats",
        "Clip": "Configuring HSTS, Public Key Pinning, and Free HTTPS CA Certificate",
        "Time in Clip": "1:05",
        "URL": "https://app.pluralsight.com/player?course=spring-security-authentication-authorization-layers-of-defense&author=wojciech-lesniak&name=e66b8355-1393-4fa9-8f6d-c3e784e96b3f&clip=5&mode=live&start=65&noteid=8e71f20d-6e55-41b7-80d3-74a04e3c13e3",
        "Tags": null
    },
    {
        "Note": "Partition is the physical representation of a topic",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Partitions in Detail",
        "Time in Clip": "1:50",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=5&mode=live&start=110&noteid=fed572b0-3ff0-41da-8a47-bf5476ef216c",
        "Tags": [
            "#kafka",
            "#partition"
        ]
    },
    {
        "Note": "\\n- **The scalability of Kafka is determined by the number of partitions being managed by multiple broker nodes.** \\n- This is the biggest way to scale kafka",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Partitions in Detail",
        "Time in Clip": "3:19",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=5&mode=live&start=199&noteid=1acfda6c-ad77-4bef-b3de-f5c4c1c732a8",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "\\n- The number of partition of a topic determines the scalability of kafka because if we have more partitions which are generally handled by 1 or more brokers which bring parallelism",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Partitions in Detail",
        "Time in Clip": "4:12",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=5&mode=live&start=252&noteid=e13b7ad9-b23e-4b46-94af-0d4d0911c5d3",
        "Tags": [
            "#kafka",
            "#partition"
        ]
    },
    {
        "Note": "8s  \\n- There can be something like mesh container for enhanced services. \\n- This sits b/w the app container and the network.\\n - For eg: encrypting/decrypting the n/w coming in and out",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Kubernetes Pods",
        "Time in Clip": "4:19",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=5&mode=live&start=259&noteid=94f6fe17-31e0-464d-ba48-045743b052cf",
        "Tags": [
            "#k",
            "#pod"
        ]
    },
    {
        "Note": "\\n- **Despite having multiple brokers, partitions for a topic, the way messages are handled is the same, i.e, time ordered sequencing of the messages**",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Apache Kafka Partitions in Detail",
        "Time in Clip": "4:23",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=5&mode=live&start=263&noteid=afec03f0-fb29-4486-b59c-0f32ecf1e9a9",
        "Tags": [
            "#kafka",
            "#topic",
            "#partition"
        ]
    },
    {
        "Note": "Confluent Schema registry is a schema registry which can be used to store schemas.\\n\\nSome more properties need to be added while creating PCs which define where the schema registry is located and ofcourse the serializers/deserializers will be changed as well\\n",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Communicating Messages Structure with AVRO and Schema Registry",
        "Clip": "Summary",
        "Time in Clip": "0:27",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=c9e8821e-4056-48c1-8a97-896276633234&clip=6&mode=live&start=27&noteid=69758fbf-a1c2-4d54-80f7-f7c94e393d70",
        "Tags": [
            "#kafka",
            "#serialization"
        ]
    },
    {
        "Note": "\\n- Zookeeper is the main player of keeping track of brokers handling the partitions. \\n- So, many brokers mean more work for the ZK. \\n- Hence, in very large scale systems. we generally have multiple clusters with their own zookeepers handling their brokers.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Distributed Partition Management in Apache Kafka",
        "Time in Clip": "3:50",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=6&mode=live&start=230&noteid=fc7c79ed-b971-4e8b-929b-f11ca1cb982d",
        "Tags": [
            "#kafka",
            "#partition"
        ]
    },
    {
        "Note": "\\n- The message distributions in the partitions are established using a **partitioning scheme** which can be established while creating them.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Distributed Partition Management in Apache Kafka",
        "Time in Clip": "4:43",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=6&mode=live&start=283&noteid=b3198ddb-2836-43e3-b0b5-091e125eac0a",
        "Tags": [
            "#kafka",
            "#topic",
            "#partition"
        ]
    },
    {
        "Note": "to have a global order, there you have to keep only 1 partition since all the partitions need to be maintained by different brokers.\\n\\nAlso there can be consumer-handling for ordering",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Distributed Partition Management in Apache Kafka",
        "Time in Clip": "4:51",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=6&mode=live&start=291&noteid=0b97527e-3717-4a66-bdff-26d11dc462bf",
        "Tags": [
            "#kafka",
            "#partition"
        ]
    },
    {
        "Note": "8s 8sService\\n- Since IP changes when any operation is performed on pods, there a service in b/w which takes care of all that.\\n- The service keeps a stable name and IP and the requests are balanced across pods by service.\\n- And there are labels which are assigned to each pods. So, any pod with same label is added to the service, it will be managed by k8s",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Stable Networking with Kubernetes Services",
        "Time in Clip": "5:30",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=6&mode=live&start=330&noteid=b0b76e1e-51e0-4a68-903f-3dfd6bf6b78d",
        "Tags": [
            "#k",
            "#K"
        ]
    },
    {
        "Note": "The object is designed with a registry which creates default objects. \\n\\nSo, when we want to create an object we clone the object we get from the registry and typeCast it.",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Prototype Pattern",
        "Clip": "Demo: Prototype",
        "Time in Clip": "8:03",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m4-prototype&clip=6&mode=live&start=483.813751&noteid=9a0e5e46-bb33-4d47-bae4-483f53e7ceed",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#prototypeDesignPattern"
        ]
    },
    {
        "Note": "\\n- When there are more brokers each handling partition. If there is some failure, the zookeeper finds a new broker for that topic. \\n- The metadata used for producers/consumers is updated and everything goes on smoothly.\\n- So, the redudancy is managed by the option --replication factor. It tells the replications of the message in the cluster.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Achieving Reliability with Apache Kafka Replication",
        "Time in Clip": "0:20",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=7&mode=live&start=20&noteid=9d5c9e2c-eeef-4e32-bb8a-cb87fa9876d9",
        "Tags": [
            "#kafka",
            "#partition"
        ]
    },
    {
        "Note": "The replication is configured per topic. \\n- By setting the replication factor to N, N-1 broker failure are tolerated.\\n- When all the topics are in sync replicas(ISR) denotes the replication factor of a topic.\\n- When the replication factor is set, it is the leaders job to get the workers to work in a quorum to replicate the logs to achieve the redundant replication level. Once the replication is upto date with the data matching the desired level of --replication factor, the data is said to be in ISR(In sync replicas) for that topic.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Achieving Reliability with Apache Kafka Replication",
        "Time in Clip": "3:47",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=7&mode=live&start=227&noteid=339cd86b-9e43-43ec-9567-f5ef98d16d1d",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "More number of partition s longer number of leader fail over time",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Achieving Reliability with Apache Kafka Replication",
        "Time in Clip": "5:38",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=7&mode=live&start=338&noteid=0e100273-6f3e-469b-b350-1ce691d751c4",
        "Tags": [
            "#kafka",
            "#partition"
        ]
    },
    {
        "Note": "--describe command gives the details of the topic",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Demo: Fault-tolerance and Resiliency in Apache Kafka",
        "Time in Clip": "0:35",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=8&mode=live&start=35&noteid=d688564e-21f1-476c-a679-043723e49b4e",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "If the ISR is not in place and there is some issue in replication, some intervention may be required to bring the ISR to desired state... and that is why proper monitoring and alerts are required to keep check of the replication",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Demo: Fault-tolerance and Resiliency in Apache Kafka",
        "Time in Clip": "5:50",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=8&mode=live&start=350&noteid=d41e8981-786b-4453-974d-0bbf762822eb",
        "Tags": [
            "#kafka",
            "#topic",
            "#partition"
        ]
    },
    {
        "Note": "8s \\nEverything in K8s is a object in it's own. All the objects are exposed by API via HTTPs/REST.",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Architecture",
        "Clip": "Epic Recap",
        "Time in Clip": "0:08",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=73f6a05d-22db-427f-aecc-2f51540558f5&clip=9&mode=live&start=8&noteid=0a5f8795-e96b-43fe-ae93-4b3de057f3ed",
        "Tags": [
            "#k",
            "#API"
        ]
    },
    {
        "Note": "When any broker goes down, the ISR is not in sync... But if we bring it back, kafka brings the ISR to the desired state by itself. Resilience",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Understanding Topics, Partitions, and Brokers",
        "Clip": "Module 3 Summary",
        "Time in Clip": "7:20",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m3&clip=9&mode=live&start=440&noteid=dc8a2049-8c5d-4464-aa83-775e6f7bd332",
        "Tags": [
            "#kafka",
            "#topic"
        ]
    },
    {
        "Note": "\\n1. Check for race conditions. They occure on fields of class. 2 threads are reading/writing a given field\\n2. Checks for the happens-before link.\\nAre the read/write volatile?\\nAre they synchronized?\\n(Remember double chek locking)\\n3. Synchronized should be used in case of atomicity\\n",
        "Course": "Applying Concurrency and Multi-threading to Common Java Patterns",
        "Module": "Implementing a Thread Safe Singleton on a Multicore CPU",
        "Clip": "How to Write Correct Concurrent Code Wrap-up",
        "Time in Clip": "0:31",
        "URL": "https://app.pluralsight.com/player?course=java-patterns-concurrency-multi-threading&author=jose-paumard&name=java-patterns-concurrency-multi-threading-m4&clip=16&mode=live&start=31.344764&noteid=ab8aee3c-12f1-4c1a-bd48-f0083a8b9431",
        "Tags": [
            "#java",
            "#concurrency",
            "#correctConcurrentCode"
        ]
    },
    {
        "Note": "\\nhttps://www.scaleway.com/en/docs/configure-apache-kafka/\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Introduction and Setting up an Apache Kafka Development Environment",
        "Time in Clip": "0:02",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=0&mode=live&start=2&noteid=92ec3c2c-7f39-4322-a47c-43774a6db62f",
        "Tags": [
            "#kafka",
            "#cluster"
        ]
    },
    {
        "Note": "Async communications: \\n- Using a message bus.\\n- Fire and forget communication\\n- Dynamic routing, i.e, change on the run to which consumer it should be sent\\n- In the case of redeploys, we don't need to worry about the services to have some downtime. Since we have the message in a message bus",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Introducing Asynchronous Communications",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=0&mode=live&start=4&noteid=4a45c338-f9da-45ac-b2ca-a74a841528be",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "\\nDecorator pattern is a heirarchical pattern which build functionality at each level while using compositions of similar data types at each level.",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Decorator Pattern",
        "Clip": "Introduction",
        "Time in Clip": "0:06",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m5&clip=0&mode=live&start=6.178274&noteid=5e1e6bc7-79f5-4fe0-b53b-0b133ef528b7",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#decoratorPattern"
        ]
    },
    {
        "Note": "Streaming is processing data in order they arrive in our system.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Introduction and Streaming Use Cases",
        "Time in Clip": "0:44",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=0&mode=live&start=44&noteid=f5f06b51-9a74-489c-bcef-6463ca51e1b2",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "Use cases -\\n- Process actions/process execution\\n- Videos\\n- Data analytics\\n- Sensor detection\\n- IOT\\n- Alerts\\n\\nSo,  everything above happens in real time",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Introduction and Streaming Use Cases",
        "Time in Clip": "1:34",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=0&mode=live&start=94&noteid=debab984-b649-43be-9a00-b4e227a8f94b",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "Advantages of Message bus:\\n1. Faster\\n2. Simpler redeploys\\n3. Absorb spike load\\n4. Isolate slow services\\n5. Easily add new service without changing existing services",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Introducing Asynchronous Communications",
        "Time in Clip": "6:31",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=0&mode=live&start=391&noteid=a227a6ac-3e0b-4b65-9e10-42a3fc96a568",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "A kafka stream always receives messages from a kafka cluster from some topic and then produces it to other topic by applying some buisness logic onto it",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Designing a Fraud Detection Application",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=1&mode=live&start=4&noteid=678512f8-129b-4cd1-b776-6bb6d2ebc05c",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "Image is a read-only template for creating application containers. Images are build-time constructs and containers are run-time siblings.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images: The Big Picture",
        "Time in Clip": "0:06",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=1&mode=live&start=6&noteid=4e3e5511-2b27-4ff3-9fbc-0b7f71059d73",
        "Tags": [
            "#docker",
            "#images"
        ]
    },
    {
        "Note": "Concepts -\\n1. Also called as wrapper.\\n2. Add behavior to object withouut affecting others\\n3. follows single responsibility principle.\\n4. Compose behaviour dynamically",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Decorator Pattern",
        "Clip": "Concepts",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m5&clip=1&mode=live&start=7.912579&noteid=47d87793-da6e-4f45-b67b-d01d04e64645",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#decoratorPattern"
        ]
    },
    {
        "Note": "KafkaProducer requires properties to connect to a kafka cluster.\\n- bootstrap.servers: The producer doesn't connect to all the broker in the list. It connects to anyone and obtains the full membership of the cluster. It determines this list to get the partitions, topics and their owners\\n- key.serializer: Kafka works on binary data. Hence, it should be serialized for kafka to understand\\n- value.serializer: Same as above\\n- The entire set of configurations can be found on: http://kafka.apache.org/documentation.html",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Basics of Creating an Apache Kafka Producer",
        "Time in Clip": "0:15",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=1&mode=live&start=15&noteid=c2b50056-b3ab-46e8-85f3-67fb59621b48",
        "Tags": [
            "#kafka",
            "#producer",
            "#producerconfigs"
        ]
    },
    {
        "Note": "Should ms be able to any ms whenever needed? Like should a frontend app should directly call any MS. There are no hard rules for such. Although these may lead to lot of issues like \\n- tangled comms.\\n- 1 failure can propagate to others\\n- Misplaced boundaries which will have many hops to fulfil the req can lead to poor performance. There can be an event bus to have async comms\\n- API gateway can be used for front end to call the backend and not each and every ms => **BFF pattern**",
        "Course": "Microservices Fundamentals",
        "Module": "Communicating Between Microservices",
        "Clip": "Microservice Communication Patterns",
        "Time in Clip": "0:15",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=fee9564e-20d2-4375-980c-5d1ab83ee26e&clip=1&mode=live&start=15&noteid=0b0f0bf1-4a29-4b50-ae51-1b51d9845adc",
        "Tags": [
            "#ms",
            "#communication"
        ]
    },
    {
        "Note": "Goals - plugins configures in maven install \\n- clean, compile, test, package install, deploy\\n\\nSuper pom has all these goals defnied in it. Goals are then added to effective pom.\\n\\nGoals are always tied to phase.\\n",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "Goals and Phases",
        "Time in Clip": "0:25",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=1&mode=live&start=25.550965&noteid=6a9dc8af-554f-482d-b01e-b39444d2de73",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "Image is OS files and objects(library files, etc), App files and a manifest(json file on how it bunches together).",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images: The Big Picture",
        "Time in Clip": "0:40",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=1&mode=live&start=40&noteid=06776f60-285e-434c-95e7-23e197dfa9d3",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "\\n- The business logic which is inside a stream so that the elements go through a series of transformations is called stream topology. \\n\\n- Topology is a acyclic graph of sources, processors and sinks",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Designing a Fraud Detection Application",
        "Time in Clip": "1:05",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=1&mode=live&start=65&noteid=2902e41d-f80f-4322-ba94-bf23e4ff4594",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "Engines in a swarm are said to run in swarm mode.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "1:09",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=69&noteid=cc24caad-131b-4f83-b812-18c68f9a46d3",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "Images are stacked on top of each other. So, it looks like a unified OS.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images: The Big Picture",
        "Time in Clip": "1:10",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=1&mode=live&start=70&noteid=a3ac5233-512c-4c86-911b-3b393944a16c",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "The series of steps which any message undergoes some transformation is called topology. The nodes in the graph are called processors. The edges are links b/w these processes which are used to transfer the messages from one process to other if the process is finished.\\n\\nThe graph is acyclic since we do not want infinite loop",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Designing a Fraud Detection Application",
        "Time in Clip": "1:11",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=1&mode=live&start=71&noteid=7b9e3957-2e98-44cd-8d06-72a355746233",
        "Tags": [
            "#kafka",
            "#streaming",
            "#topology"
        ]
    },
    {
        "Note": "Images are stored in image registry(remote/local)",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images: The Big Picture",
        "Time in Clip": "1:35",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=1&mode=live&start=95&noteid=24cb8cfa-2c7d-475a-93d9-a23f6d22b023",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "Phases\\n1. validate - validate if the project is correct and all necessary information is available\\n2. compile - compile the source code of project\\n3. test - test the compiled source code\\n4. package - packages the code in its defined package, such as jar.\\n5. integration-test -> copy final package to a remote repository. This is used to run integration tests, etc\\n6. veriy\\n7. deploy\\n8.",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "Goals and Phases",
        "Time in Clip": "1:35",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=1&mode=live&start=95.143248&noteid=6bac52b0-92e3-4c91-84b9-a7bf9447bc78",
        "Tags": [
            "#java",
            "#amven"
        ]
    },
    {
        "Note": "You do not need to enable swarm mode.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "1:43",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=103&noteid=9fd1ece1-01f7-4cbe-b2e1-e3716775a578",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "Types of processor: \\n- Source processor: Consumer which consumes from a topic is known as Source. It specifies from where we are getting the data.\\n- Sink processor: Produces the data to a certain topic and determines where should the data be sent. It is the end processor of a stream topology. There can be multiple number of sink processors. \\n- Stream processors: The intermediate processors are called stream processors. Stream processors are chained together for some processing.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Designing a Fraud Detection Application",
        "Time in Clip": "1:43",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=1&mode=live&start=103&noteid=1c118ce8-f074-4e61-88f1-b15331afb684",
        "Tags": [
            "#kakfka",
            "#streaming",
            "#topology"
        ]
    },
    {
        "Note": "There are one or more manager nodes and manager nodes maintain the swarm. Managers are highly available.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "2:04",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=124&noteid=9c39f55a-eca0-4902-9c51-21d13e13177f",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "Traditional design for streaming use cases can introduce some hard bindings in b/w the services used for processing the use case.\\n\\nFor eg: Payment service\\nWe first need a Validator to validate the payment. To validate, we would it to some Fraud detection service for detecting frauds. Also, since we are sending it some other service we need some kind of persistence for storing the payment info.\\n\\nHere we can we observe 2 binding with each other - Validator and Fraud detection service cannot exist without one another. Also, we have a DB which would be a req and all these cannot exist without each other",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Designing a Fraud Detection Application",
        "Time in Clip": "2:10",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=1&mode=live&start=130&noteid=4f97941c-b16d-45b0-ad29-6abe0cd21f9e",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "It is said to have odd number of nodes. But there will be only one node. We can distribute managers on regions, availability, etc.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "2:25",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=145&noteid=9b5ae2aa-431f-4a98-8bda-e21b7c8ac312",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "The write part in the containers is layer with the containers. So, it becomes a one-to-many relation b/w image and write layer.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images: The Big Picture",
        "Time in Clip": "2:28",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=1&mode=live&start=148&noteid=edfb7d26-bd80-44d3-9cff-93a14387b8b2",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "All containers share the same image.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images: The Big Picture",
        "Time in Clip": "2:36",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=1&mode=live&start=156&noteid=92ea3c57-1c3e-4b34-b5d0-8bc5ce706cdb",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "\\n- Payment service , Fraud detection Payment processor are components for payments.\\n\\n- We can have 2 topics payments and validated payment for processing.\\n\\n- Incoming payments will go to payments topics. Then the fraud detection app will act as a consumer to this topic and validate the payment. If it passes it will produce this payment to the next topic validated-payments. Then our payment processor will only have to process payments which are part of this topic. \\n\\n- So, our traditional design of making payments can be transformed to a Event driven model by having kafka as a broker in between transferring the messages.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Designing a Fraud Detection Application",
        "Time in Clip": "2:44",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=1&mode=live&start=164&noteid=eed884f2-9630-4c0f-90c7-cb43e7eb383d",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "RAFT is the protocol used in the background to bring it to a consensus.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "3:10",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=190&noteid=7d918e8f-178b-41e1-8a0c-10e5587443cd",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "Worker nodes just accept task from managers and execute them.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "3:33",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=213&noteid=7438145b-6ba5-4ded-afd5-200bcd0723eb",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "Services is a declarative way of scaling tasks. docker service create --name web-fe --replicas 4",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "4:01",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=241&noteid=19a98d4f-e138-45ad-84e8-01d56cc672bb",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "\\n- On instantiation of Producer, the ProducerConfig class is instantiated and from there are configurations are defined from here.\\n- This configs should also be applicable to the consumers,",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Basics of Creating an Apache Kafka Producer",
        "Time in Clip": "4:19",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=1&mode=live&start=259&noteid=d4cc0005-d087-4c0b-be46-f71e759045a2",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "Task is an atomic unit of work assigned to a worker node. Task means containers.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "5:35",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=335&noteid=111bd1b1-6f61-49ab-bd29-4fce6a6170aa",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "Its all about proper native clustering. The native cluster is called a swarm. A collection of docker engines joined together is called swarm.",
        "Course": "Getting Started with Docker",
        "Module": "Swarm Mode and Microservices",
        "Clip": "Swarm Mode Theory",
        "Time in Clip": "5:49",
        "URL": "https://app.pluralsight.com/player?course=docker-getting-started&author=nigel-poulton&name=docker-getting-started-m4&clip=1&mode=live&start=349&noteid=b010fda4-e43e-42a4-8104-5af0c101446c",
        "Tags": [
            "#docker",
            "#swarmmode"
        ]
    },
    {
        "Note": "Compiler plugin - plugin which is used to compile our src/test code. It works in both phases. \\nIt defaults to Java 1.5 regardless of what JDK is installed.\\n<configuration> tag is used to configure it\\n<fork>true</fork> -> to spin off on its own thread\\n<maxmem></>\\n<meminitial></>\\n<source></source>\\n<target></target>\\n",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "The compiler plugin",
        "Time in Clip": "0:02",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=2&mode=live&start=2.047968&noteid=4d932d73-1035-4513-868b-54ed6128cbc2",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "Kafka Streams only takes the input from a particular topic and no other place",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Kafka Streams",
        "Time in Clip": "0:26",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=2&mode=live&start=26&noteid=743f9ea8-0295-49e8-848c-9a2f8abbac16",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "Image is independent layers that are loosely coupled using a manifest file. All the layers are not aware of the other layers in an image.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images in Detail",
        "Time in Clip": "0:48",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=2&mode=live&start=48&noteid=9324e635-014f-4d80-b873-470f0714c49f",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "Pulling a image is 2 step process. 1. Get manifest 2. Pull layers",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images in Detail",
        "Time in Clip": "2:13",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=2&mode=live&start=133&noteid=b311f22d-9fe0-4748-ac87-e639dc8a1e41",
        "Tags": [
            "#docker",
            "#pullimage"
        ]
    },
    {
        "Note": "\\n- Producer only sends in ProducerRecord which requires topic and message.\\n- When sending the value the serialization type must be specified so that the consumer can also know what kind of messages are to be expected.\\n- Sending something to kafka which it doesn't understand will cause errors.\\n- The other things which can be sent to the cluster are - partition and timestamp. \\n - Partition allows the producer to know which partition should the message be sent.\\n - Timestamp is sent with each record. We can configure timestamp value using 2 properties:\\n   - CreateTime: preset by producer at the time of creation\\n   - LogAppendTime: set as the time when the broker commits to the log. The value sent by the producer is overwritten.\\n - Key: Key is used as additional info in the message which can be used to make processing discission.\\n   - Also this can determine which partitions the message will be written to.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Creating and Preparing Apache Kafka Producer Records",
        "Time in Clip": "2:59",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=2&mode=live&start=179&noteid=f13e0957-ee76-48d7-abda-4e86a24c98d8",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "First docker gets the fat manifest(manifest of manifests - List of architecture supported). If the architecture of the machine is present in the fat manifest, if present we get the image manifest for that architecture. Once we get that, we pass it to the  list of layers and download it from its blobs.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images in Detail",
        "Time in Clip": "3:06",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=2&mode=live&start=186&noteid=0fd91ab7-5b48-47ae-8ac8-7e082504c46f",
        "Tags": [
            "#docker",
            "#pullimage"
        ]
    },
    {
        "Note": "Content Addressable Storage - Every layer has got a bunch of files and stuff inside. So, grab a hash of all the contents and get the image ID from that. So, we get the correct image and properly stacked and linked together.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images in Detail",
        "Time in Clip": "4:03",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=2&mode=live&start=243&noteid=b1cc98ae-76e8-4b49-ac07-b90ebb3e3777",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "The base layer of an image is the OS layer. The base layer should be the same as the kernel it is running on(except the Hyper-V containers).",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Images in Detail",
        "Time in Clip": "5:54",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=2&mode=live&start=354&noteid=36cf852f-2b92-4881-a288-9e6e3542d44d",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "Duality of streams:\\nMost of the times we need databases while processing. Hence the streams can be looked at in 2 ways:\\n1. Stream: Normal stream\\n2. Table: Perceive a stream where we persist the messages with the latest state of message. For eg. Banking acc data\\n\\nWe can convert each of the streams vice-versa",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Duality of Streams",
        "Time in Clip": "0:11",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=3&mode=live&start=11&noteid=98e02cef-26d1-439e-a149-2632d8c07b62",
        "Tags": [
            "#kafka",
            "#streaming"
        ]
    },
    {
        "Note": "EDA: Concerns with Distributed Transactions:\\n1. Message Routing: Process by a distributed transaction is coordinated across different services. So, if we have a single service that is responsible for maintaining the transaction flow, it becomes easier to understand the flow of the transaction. Also, this helps in having everything in one place and reduces coupling b/w different services.\\n2. Transaction State: We can centralize this as well.\\n3. Failure compensation: \\n",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Distributed Transactions",
        "Time in Clip": "3:22",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=3&mode=live&start=202&noteid=159da5b8-ecab-4e53-a4e4-2b02b8480f7e",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Type of message types: \\n1. Command\\n2. Events\\n\\n*Enterprise Integration patterns are used for message integrating services\\n*",
        "Course": "Microservices Fundamentals",
        "Module": "Communicating Between Microservices",
        "Clip": "Asynchronous Communication",
        "Time in Clip": "3:50",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=fee9564e-20d2-4375-980c-5d1ab83ee26e&clip=3&mode=live&start=230&noteid=711f8cee-860c-49df-8772-1ccfbd4454cf",
        "Tags": [
            "#ms",
            "#communication"
        ]
    },
    {
        "Note": "Registeries have images. These are basically loosely coupled layers with a manifest file. Each layer has a content hash.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Registries",
        "Time in Clip": "6:19",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=3&mode=live&start=379&noteid=1e8b9b0d-91b0-485f-b3cf-ef7eeef6a529",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "When we push the image to a registry, we compress it. So, the content hashes give an error when they are tested for integrity. To get around it, we populate it with new hashes with new IDs. These are called distribution hashes.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Images",
        "Clip": "Registries",
        "Time in Clip": "7:14",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=5d5c5fa0-18f8-46b6-a1ef-90d6c2d925ef&clip=3&mode=live&start=434&noteid=5bdfac63-9fb7-4415-ba40-e8c86d582933",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "Patterns for EDA:\\n1. Saga Pattern: \\n- It is described on how to deal with transactions which take long-lived transactions(LLTs)\\n- It described on how to use fine-grained transactions to express an LLTs.\\n- Compensating operations are also covered in this.\\n- It is also used to centralize the transaction state\\n- Also used for message routing",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Saga Pattern and Routing Slip Pattern",
        "Time in Clip": "0:03",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=4&mode=live&start=3&noteid=1662f50d-1c18-4463-816d-238e74102037",
        "Tags": [
            "#microservice",
            "#EDA"
        ]
    },
    {
        "Note": "Types of processors:\\n- Stateless - The processor doesnt need to know the state of message for processing\\n- Stateful - The processor needs some kind of state store for processing",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Stateless and Stateful Processors",
        "Time in Clip": "0:10",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=4&mode=live&start=10&noteid=8fae7016-7331-403b-9d60-632f04db79da",
        "Tags": [
            "#kafka",
            "#streaming",
            "#processors"
        ]
    },
    {
        "Note": "Jar plugin\\n- Used to package code into a jar\\n- tied to package phase\\n- configurations\\nincludes/excludes\\nmanifest",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "The jar plugin",
        "Time in Clip": "0:11",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=4&mode=live&start=11.56845&noteid=faa9baad-0511-4705-b8fe-2edc6c1c8457",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "Examplle - InputStream",
        "Course": "Design Patterns in Java: Structural",
        "Module": "Decorator Pattern",
        "Clip": "Example: File",
        "Time in Clip": "0:19",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-structural&author=bryan-hansen&name=design-patterns-java-structural-m5&clip=4&mode=live&start=19.814496&noteid=c0c3a0d6-7d9a-42d2-84e3-78d42abbcc83",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#structuralPattern",
            "#decoratorPattern"
        ]
    },
    {
        "Note": "Types of Stateless operation:\\n1. Branch: split the stream in multiple branches branches based on some buisness use case\\n2. Filter: Filter the messages\\n3. Inverse Filter: Inverse of filter\\n4. Map\\n5. FlatMap\\n6. Foreach - terminal event. So, we wont be able to use a sink processor\\n7. GroupBy\\n8. Merge",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Stateless and Stateful Processors",
        "Time in Clip": "0:39",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=4&mode=live&start=39&noteid=417c353b-caca-4024-a6d0-6c4fe70d45c6",
        "Tags": [
            "#kafka",
            "#streaming",
            "#processors"
        ]
    },
    {
        "Note": "Resilient communication patterns: In case of communication based messaging, there are bound to be n/w failure here and there. To have resilience across the solution lot of patterns can be used like:\\n- Retries with back-off\\n- Circuit breaker: Retries can lead to DoS attack on the downstream service if lot of reties are issued. \\n - There is a circuit in b/w client and server which is closed when everything is working fine. \\n - If there are some failure in the downstream service, the circuit opens up and does not allow req to go through. After some time it again closes to requests to go through.\\n- Caching can also improve resilience",
        "Course": "Microservices Fundamentals",
        "Module": "Communicating Between Microservices",
        "Clip": "Resilient Communication Patterns",
        "Time in Clip": "0:44",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=fee9564e-20d2-4375-980c-5d1ab83ee26e&clip=4&mode=live&start=44&noteid=74069380-5f14-4246-a5df-d001ba587608",
        "Tags": [
            "#ms",
            "#communication"
        ]
    },
    {
        "Note": "Saga Pattern:\\nEg of a post on social media:\\nThe things which we would have to process would be - Post it on timeline, Photo screening of content, Update user advertising profile and payment processing\\n\\nAccording to Saga pattern:\\n- First the Post is persisted in some storage which is maintained by some service.(just an example) It also keeps a state for that post.\\n- Then the saga would publish it to Timeline. Then the timeline service will publish it to the Saga updating its state. \\n- And this continues by updating the state of the post after completion of each Post.\\n- This results in centralized service(Saga) to keep track of the entire workflow and state of the message, aka, centralization of distributed transactions\\n- Once the transaction is completed, it can be safely removed from the Saga\\n",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Saga Pattern and Routing Slip Pattern",
        "Time in Clip": "0:59",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=4&mode=live&start=59&noteid=9e6737c6-e4b0-4d95-9b23-ab260e60ade8",
        "Tags": [
            "#microservices",
            "#EDA"
        ]
    },
    {
        "Note": "\\n- Once a producer record is received, the producer gets the bootstrap servers list to get the cluster membership and gets metadata containing detailed info of topics, partitions, brokers, etc.\\n- The producer gets the configs of the cluster and keeps it alive throughout the lifecycle.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "The Process of Sending Messages, Part One",
        "Time in Clip": "1:00",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=4&mode=live&start=60&noteid=fe52183b-5e90-4369-a1b7-74ea738733da",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "Types of Stateful operation:\\n1. Aggregations\\n2. Count\\n3. Joins\\n4. Windowing\\n5. Custom",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building Your First Streaming Application",
        "Clip": "Stateless and Stateful Processors",
        "Time in Clip": "1:48",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=1495468c-5fa5-45f3-bad0-a3b9ffdd3561&clip=4&mode=live&start=108&noteid=48413cdf-f977-49ed-8f5a-351dce7227aa",
        "Tags": [
            "#kafka",
            "#streaming",
            "#processors"
        ]
    },
    {
        "Note": "Saga is modeled as a State machine(DFA Dicrete Finite Machine).\\n- Saga work when they receive event messages.",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Saga Pattern and Routing Slip Pattern",
        "Time in Clip": "2:42",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=4&mode=live&start=162&noteid=deb5c780-32e4-45f2-82c6-3509af8405ec",
        "Tags": [
            "#microservices",
            "#EDA"
        ]
    },
    {
        "Note": "Messaging resilience:\\n- Messaging has inherit behavior of resilience since it can catch up  later after coming back up\\n- It supports re-deliveries\\n- can be received out of order\\n- can be received multiple times\\n - Hence the handlers need to be ***idempotent***",
        "Course": "Microservices Fundamentals",
        "Module": "Communicating Between Microservices",
        "Clip": "Resilient Communication Patterns",
        "Time in Clip": "4:57",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=fee9564e-20d2-4375-980c-5d1ab83ee26e&clip=4&mode=live&start=297&noteid=f555c97d-d165-4a3f-a399-1b0c9a1d4bd9",
        "Tags": [
            "#ms",
            "#communication"
        ]
    },
    {
        "Note": "We can even modify DFA to handle failures as well.\\n- So, we can have cancellation events to go back and rollback the transactions performed on each satte",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Saga Pattern and Routing Slip Pattern",
        "Time in Clip": "5:54",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=4&mode=live&start=354&noteid=b4d056ed-b427-40e3-b5b4-fc9df248033a",
        "Tags": [
            "#microservices",
            "#EDA"
        ]
    },
    {
        "Note": "Routing slip pattern: It is used to facilitate the work at each step.\\n- A routing slip contains the information/instruction which needs to be performed at each transition.\\n- So, at each station, it does the work and pass the item to the next station.\\n- So, we don't have a centralized service to handle the transactions in the message bus. \\n- But instead there is a routing slip pattern, we determine processing steps and is attached with the message.\\n- On each step, it updates the routing slip on each step which can be available/imp for the next steps\\n- This also gives a flexibility for routing the messages. So, if we don't want to perform some step in the process, we can just change the routing slip and this can be directly used to route the message.\\n- Failure compensation: We can have a steps traced backwards in case of failure described in the routing slip.\\n\\n\\nDrawback of routing slip -\\n1. No state centralization\\n- May be a performace improvement",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Saga Pattern and Routing Slip Pattern",
        "Time in Clip": "8:39",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=4&mode=live&start=519&noteid=f6a127b2-5e5b-49d0-8a59-21fe7605d72a",
        "Tags": [
            "#miroservices",
            "#EDA"
        ]
    },
    {
        "Note": "How the record is sent to kafka:\\n- First we get the metadata from the cluster which has info on all the topics/partitions and their owners.\\n- **Serialization**: It is serialized based on the serializer defined while creating the producer.\\n- **Partitioning**: Partition strategies are used to send messages to the cluster. The types of strategies:\\n - ***Direct*** to the partition present in the record. The partition is matched from the metadata object which is instantiated on start. \\n - ***Key*** - If direct partition is not present, it checks if any key is **not** present in the producer record, then the record is sent to the cluster using a **round robin** fashion. \\n - If ***Key*** is provided then it looks for ProducerConfig for a partitioning class. If that is not present then the message is sent based on some key hashing function.\\n - If **Custom partitioner** is provided in the ProducerConfig, that class is used to partition the message to the cluster.\\n- RecordAccumulator: Once the partitioning scheme is finalized, the above things are cleared, an internal queue in Kafka client is used to push messages to cluster. **Micro batching** is used over here to scale by sending records at high frequencies and be more efficient. RecordBatch object is created based on the topic partition and kept in the buffer. The release of this RecordBatch can be handled by props.\\n- RequestMetadata: Once the record is sent to cluster a request metadata object is sent back of its ack.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "The Process of Sending Messages, Part Two",
        "Time in Clip": "1:57",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=5&mode=live&start=117&noteid=bb85f978-0f6c-4c15-bb03-09083f6e88c1",
        "Tags": [
            "#kafka",
            "#client",
            "#producer"
        ]
    },
    {
        "Note": "Dead letter Q can be used for error handling where any messages which goes in error state would be sent to dead letter Q",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Review: Asynchronous Communications",
        "Time in Clip": "2:16",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=5&mode=live&start=136&noteid=4b03437c-4af5-4595-849a-278aa4af2819",
        "Tags": [
            "#microservices",
            "#EDA"
        ]
    },
    {
        "Note": "Kafka can be enabled with micro batch processing be it on producer side or consumer side.\\n\\nRecordBatch object is used in record accumulator while pushing to cluster in micro batches",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "The Process of Sending Messages, Part Two",
        "Time in Clip": "2:39",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=5&mode=live&start=159&noteid=32a6fbe8-f663-4d6a-9751-9b6803e76f16",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "In Async communications, any transaction moves to Eventual Consistency, i.e, the transaction as a whole is not consistent till all the transaction is committed across all services.\\n\\nFor eg: Like on a Post is recorded but the notification is not sent yet",
        "Course": "Microservices: Getting Started",
        "Module": "Asynchronous Communication Architectures",
        "Clip": "Review: Asynchronous Communications",
        "Time in Clip": "4:35",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=e8411389-8f53-4b9f-9814-08e68e25517e&clip=5&mode=live&start=275&noteid=1d611215-420e-42cf-b74b-3dbd425033cf",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "RecordBatch configuration:\\n\\n- batch.size: This value refers to the max bytes stored in each Record Batch\\n- buffer.memory: Max memory that can be used for buffering\\n- max.block.ms: If max buffer is reached, this tells how much time the send() method will be blocked for. This blocking contingency is used to produce back pressure onto the producer thread to send more records.\\n- linger.ms: Number of millis should wait for the Record batch to fill up and send in case of not full buffers.\\n- acks: Finally RecordMetada is sent back for the records which are sent to kafka. The setting of acknowledgment for the message.\\n  - 0:Fire and forget - no ack is sent\\n  - 1: leader ack - Only leader acknowledged\\n  - 2: replication quorum ack - All the workers in quorum send acks",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Message Buffering and Micro-batching",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=6&mode=live&start=7&noteid=a8226a77-c918-40df-b79e-fafcb6d2107b",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "Source plugin \\n- Used to attach source code to a jar\\n- tied by default to package phase",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "The source plugin",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=6&mode=live&start=7.311878&noteid=6bbf1c7b-97b4-4e57-8514-d53c2e4f4dd2",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "Error configuration:\\n- retries: How many times the producer will retry in case of errors.\\n- retry.backoff.ms: Specify the wait period b/w each retry.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Message Delivery and Ordering Guarantees",
        "Time in Clip": "2:18",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=7&mode=live&start=138&noteid=f7e013a5-b9f2-4f22-b089-dfe24864b1cb",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "Ordering guarantees:\\n- Message order by partition - The consumers will also consume on the same basis\\n- So, no global order across partitions.\\n- max.in.flight.request.per.connection: At any given time, only one request to be made. This comes at a cost. This can come in handy in case the retries, retry.backoff.ms has some sync issues where the message ack is not yet received and assuming it to be an error one more message is sent.\\n- Delivery semantics stating how we should send the message can also be set and with what assurance. \\n - At-most-once\\n - At-least-once\\n - only-once",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Message Delivery and Ordering Guarantees",
        "Time in Clip": "2:50",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=7&mode=live&start=170&noteid=08062cb6-85b1-4de3-9fbd-3b92a2604670",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "Javadoc plugin \\n- used to attach javadocs to a jar\\n- tied to package phase",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "The javadoc plugin",
        "Time in Clip": "0:07",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=8&mode=live&start=7.010508&noteid=848046e9-65ba-4744-b6aa-185622ec95cd",
        "Tags": [
            "#java",
            "#maven"
        ]
    },
    {
        "Note": "Advanced topics to check:\\n- Custom serializers\\n- Custom partitioners\\n- Asynchronous Send with Future object\\n- Compression types",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Producing Messages with Kafka Producers",
        "Clip": "Advanced Topics and Module 4 Summary",
        "Time in Clip": "0:29",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m4&clip=9&mode=live&start=29&noteid=81453817-3233-44a7-a66f-659c663ddb83",
        "Tags": [
            "#kafka",
            "#producer"
        ]
    },
    {
        "Note": "A Maven phase represents a stage in the Maven build lifecycle. Each phase is responsible for a specific task.\\nHere are some of the most important phases in the default build lifecycle:\\nvalidate: check if all information necessary for the build is available\\ncompile: compile the source code\\ntest-compile: compile the test source code\\ntest: run unit tests\\npackage: package compiled source code into the distributable format (jar, war, …)\\nintegration-test: process and deploy the package if needed to run integration tests\\ninstall: install the package to a local repository\\ndeploy: copy the package to the remote repository",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "Summary",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=10&mode=live&start=0&noteid=6571eec0-f171-49dd-bb99-fd36ce774b97",
        "Tags": null
    },
    {
        "Note": "Phases are executed in a specific order. \\n\\n This won’t only execute the specified phase but all the preceding phases as well.",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "Summary",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=10&mode=live&start=0&noteid=013405de-4b02-4bb0-9f7b-c5ff8f515cee",
        "Tags": null
    },
    {
        "Note": "We can use the following command to list all goals in a specific plugin:\\n\\nmvn <PLUGIN>:help",
        "Course": "Maven Fundamentals",
        "Module": "Maven Plugins",
        "Clip": "Summary",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=maven-fundamentals&author=bryan-hansen&name=maven-fundamentals-m5&clip=10&mode=live&start=0&noteid=c9ce275f-4906-4fc7-9d61-b2da23b6d710",
        "Tags": null
    },
    {
        "Note": "\\n1. The factory is parameter driven. \\n2. It allowes runtime creation of any type.\\n3. It can get a little more complex.",
        "Course": "Design Patterns in Java: Creational",
        "Module": "Factory Method Pattern",
        "Clip": "Summary",
        "Time in Clip": "1:17",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m5-factory&clip=10&mode=live&start=77.694&noteid=dc138448-5881-46a0-9c20-93e6d34579f1",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#factoryDesignPattern"
        ]
    },
    {
        "Note": "streaming engine for ease of viewers over streams",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building a Streaming Application with KSQL",
        "Clip": "Introduction",
        "Time in Clip": "0:08",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=40bac18e-2dc9-44e3-9b06-6e9deb5a28ba&clip=0&mode=live&start=8&noteid=4e8d15c4-e8bc-442b-8445-a2790fd51fe0",
        "Tags": [
            "#kafka",
            "#KSQL"
        ]
    },
    {
        "Note": "Any API has Inputs(requests), Outputs(Dependencies) and Logic.\\n\\nThe output is called system boundary.\\n\\nOnce you know all these things... we can use Integration testing and use real life services/dependencies",
        "Course": "Microservices: Getting Started",
        "Module": "Developing Features in a Microservices Architecture",
        "Clip": "Controlling the Quality of a Microservice",
        "Time in Clip": "1:53",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=52cf1167-5255-486a-b010-ccd5652adab6&clip=0&mode=live&start=113&noteid=8de4c9f4-21e0-4286-8824-8c05177c8348",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "The Testing Pyramid:  We should have Units tests at the base level, integration tests in middle and then finally UI tests.",
        "Course": "Microservices: Getting Started",
        "Module": "Developing Features in a Microservices Architecture",
        "Clip": "Controlling the Quality of a Microservice",
        "Time in Clip": "3:16",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=52cf1167-5255-486a-b010-ccd5652adab6&clip=0&mode=live&start=196&noteid=ec615a20-cdec-4e34-8d40-abf6760a46f2",
        "Tags": [
            "#microservices",
            "#testing"
        ]
    },
    {
        "Note": "So, anyone with no programming ex can develop a Stream using KSQL",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building a Streaming Application with KSQL",
        "Clip": "KSQL Basics",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=40bac18e-2dc9-44e3-9b06-6e9deb5a28ba&clip=1&mode=live&start=0&noteid=b5b5ecbc-8fde-4ab1-9fe0-9e4ba7e381e4",
        "Tags": [
            "#kafka",
            "#KSQL"
        ]
    },
    {
        "Note": "Sensitive Data:\\n- All the data should not be accessible to everyone\\n- Like the user details should not be visible to the end-user\\n- Hence the data should be **encrypted in transit**. The algorithms should use standard algorithms\\n- TLS can be used and SSL certificates\\n- **Encryption at rest**:\\n - Data should be encrypted when at rest",
        "Course": "Microservices Fundamentals",
        "Module": "Securing Microservices",
        "Clip": "Encrypting Data",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=39acc17b-daff-426a-a523-bd878e02872e&clip=1&mode=live&start=4&noteid=38ee521d-913e-40b6-885b-fe7fb19a31ed",
        "Tags": [
            "#ms",
            "#security"
        ]
    },
    {
        "Note": "\\n- A single consumer can subscribe to any number of topics.\\n- Calls to subscribe are not incremental.\\n- Basic use of subscribe makes the consumer dynamically/automatically listen to partitions in a topic.\\n - It can be one topic, one-to-many partitions\\n - Many topics, and many more partitions.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Subscribing and Unsubscribing to Topics",
        "Time in Clip": "0:26",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=1&mode=live&start=26&noteid=ce67da7b-8261-4388-8027-a0bc98cd2fe4",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "Feature development: \\n1. API Versioning: We can have API versioning in place to have backwards compatibility for existing users. Hence, it can a bit troublesome for devs of service to provide backward compatibility.\\n2. Feature Toggles: \\n- Enable/Disable features based on some condition\\n- Condition mechanism varies based on control needed.\\n- Release toggle\\n- Experimental toggle",
        "Course": "Microservices: Getting Started",
        "Module": "Developing Features in a Microservices Architecture",
        "Clip": "Continuous Delivery Techniques",
        "Time in Clip": "1:48",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=52cf1167-5255-486a-b010-ccd5652adab6&clip=1&mode=live&start=108&noteid=48cfabb1-fc83-4526-8f53-89b7677ecead",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "CREATE STREAM pineapple_pizza AS \\nSELECT crust, size, toppings \\nFROM pizza \\nWHERE type = 'pineapple';",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building a Streaming Application with KSQL",
        "Clip": "KSQL Basics",
        "Time in Clip": "3:22",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=40bac18e-2dc9-44e3-9b06-6e9deb5a28ba&clip=1&mode=live&start=202&noteid=c9127ac1-491c-43c9-beda-b16b8873b514",
        "Tags": [
            "#kafka",
            "#KSQL"
        ]
    },
    {
        "Note": "So, every query will generate a topology representing the query",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building a Streaming Application with KSQL",
        "Clip": "KSQL Basics",
        "Time in Clip": "3:28",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=40bac18e-2dc9-44e3-9b06-6e9deb5a28ba&clip=1&mode=live&start=208&noteid=a24e71d8-c526-4aab-acaf-f02d2a7e95a7",
        "Tags": [
            "#kafka",
            "#KSQL"
        ]
    },
    {
        "Note": "\\n1. Groups factories together.\\n2. A common interface needs to be implemented across all classes\\n3. An abstractFactory design uses composition.",
        "Course": "Design Patterns in Java: Creational",
        "Module": "AbstractFactory Pattern",
        "Clip": "Design Considerations",
        "Time in Clip": "0:15",
        "URL": "https://app.pluralsight.com/player?course=design-patterns-java-creational&author=bryan-hansen&name=design-patterns-java-creational-m6-abstract-factory&clip=2&mode=live&start=15.065176&noteid=5d7d30ce-b2f4-41c2-964c-fbb7a22bc24a",
        "Tags": [
            "#java",
            "#javaPatterns",
            "#AbstractFactoryDesignPattern"
        ]
    },
    {
        "Note": "\\n- The consumer subscribes to a particular topic. This is done by passing the topic list to our consumers.\\n- Once a topic is subscribed to by the consumer, the partitioning is all done automatically. So, there is another alternative to this by assigning a single partition to the consumer.\\n- http://kafka.apache.org/documentation.html\\n\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Comparing Subscribe and Assign APIs",
        "Time in Clip": "1:20",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=2&mode=live&start=80&noteid=1ff52811-0097-43db-8600-5bc307e2fa20",
        "Tags": [
            "#kafka",
            "#consumer",
            "#consumerconfigs"
        ]
    },
    {
        "Note": "HTTP authorization options should be used while request calls\\n- Basic Auth: This should be carefully dealt with since the service is responsible for password storage\\n- API key: Key could be passed when multiple services are communicating b/w them. In such cases the key should be properly managed, rotated in case it is compromised\\n- Client certificate: Public key cryptography\\n\\n**All the above have lot of overhead for all the services to implement. Hence using an Identity server**",
        "Course": "Microservices Fundamentals",
        "Module": "Securing Microservices",
        "Clip": "Authentication",
        "Time in Clip": "1:24",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=39acc17b-daff-426a-a523-bd878e02872e&clip=2&mode=live&start=84&noteid=dd558c39-ff41-4123-8372-196db34d8b08",
        "Tags": [
            "#ms",
            "#security"
        ]
    },
    {
        "Note": "assign() is also used to subscribe to a particular topic. \\n- This something like assigning oneself to a particular topic/partition.\\n- One or more partitions, regardless of topics.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Comparing Subscribe and Assign APIs",
        "Time in Clip": "1:28",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=2&mode=live&start=88&noteid=d6bf3e7f-614b-407a-aa51-01cd2d876025",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "Identity Service: Use OAuth2.0 & OpenID connect. \\n- Only one server Identity service is responsible for authorizing the request user. \\n- Use 3rd party solutions which follow industry standards\\n- The token can be shared among services and the server can verify the token",
        "Course": "Microservices Fundamentals",
        "Module": "Securing Microservices",
        "Clip": "Authentication",
        "Time in Clip": "2:30",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=39acc17b-daff-426a-a523-bd878e02872e&clip=2&mode=live&start=150&noteid=f70fa615-8218-4e16-9f43-76dd3805b642",
        "Tags": [
            "#ms",
            "#secutriy"
        ]
    },
    {
        "Note": "The image metadata file contains a Dockerfile.\\n\\nThis file contains instructions and values.\\n\\n- CAPITALIZE instructions\\n- <instruction> <value>\\n- FROM always first instruction. Usually an OS image (alpine, ubuntu)\\n- FROM means base image\\n- Good practice to list maintainer\\n- RUN = execute a command and create a layer\\n- COPY = copy code into image as new layer\\n- Some instructions add metadata instead of layers\\n- ENTRYPOINT = default app for image/container",
        "Course": "Docker Deep Dive",
        "Module": "Containerizing an App",
        "Clip": "Containerizing an App",
        "Time in Clip": "5:07",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2888a54f-a5b8-4192-919d-827c795ff718&clip=2&mode=live&start=307&noteid=a1e93fa6-e946-48d8-9b00-334ad97fddfb",
        "Tags": [
            "#docker",
            "#image"
        ]
    },
    {
        "Note": "TopicPartition is used to subscribe to a particular partition using assign() API",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Single Consumer Subscriptions and Assignments",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=3&mode=live&start=4&noteid=0539bccd-c01b-4816-925c-d01c1526f0b0",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "The ms services should be on a secured n/w and no one else should be able to call them. But in case front end needs to call the microservice, it should allow them. So, how will services add a firewall against the open internet. Solution => **API gateway**. \\n- So, the frontend only call the API gateway and the services are on a virtual n/w and not on the open internet",
        "Course": "Microservices Fundamentals",
        "Module": "Securing Microservices",
        "Clip": "Securing the Network",
        "Time in Clip": "2:10",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=39acc17b-daff-426a-a523-bd878e02872e&clip=4&mode=live&start=130&noteid=ec771731-c846-457b-9dc5-5e228d6f9cc6",
        "Tags": [
            "#ms",
            "#security"
        ]
    },
    {
        "Note": "Defense in Depth: We should rely on multiple security measures and not just one of them like:\\n- Encryption in transit\\n- Access tokens\\n- N/w security: virtual n/w, API gateway\\n- Penetration testing should be done\\n- Automated tests for security\\n- Attack detection and alert can be configured",
        "Course": "Microservices Fundamentals",
        "Module": "Securing Microservices",
        "Clip": "Defense in Depth",
        "Time in Clip": "0:00",
        "URL": "https://app.pluralsight.com/player?course=microservices-fundamentals&author=mark-heath&name=39acc17b-daff-426a-a523-bd878e02872e&clip=5&mode=live&start=0&noteid=cf60ec11-0d9f-48a6-bd2d-7e2ebb65827a",
        "Tags": [
            "#ms",
            "#security"
        ]
    },
    {
        "Note": "The Poll Loop:\\n- The consumers polls the topics constantly to fetch new messages. \\n- This is the most important function of a Kafka Consumer. Nothing happens till the time this poll loop is initialized.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Demo: Simple Kafka Consumer",
        "Time in Clip": "0:05",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=5&mode=live&start=5&noteid=9ff07da2-d307-4b8c-902f-9ec5ffc54e03",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "Windowing: This is used to window the data based on time sequence and can be very helpful in processing the data from KSQL streams.\\nThis can be used for alerting purposes.\\n\\nTypes of Window:\\n1. Interval: The windows are on intervals like 15-15 minutes.\\n2. Hopping: The window will hop with some interval. This can be visualized by sliding window.",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Building a Streaming Application with KSQL",
        "Clip": "Summary",
        "Time in Clip": "0:36",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=40bac18e-2dc9-44e3-9b06-6e9deb5a28ba&clip=5&mode=live&start=36&noteid=faca9a82-6015-49d1-8ef1-53221065fb7e",
        "Tags": [
            "#kafka",
            "#KSQL"
        ]
    },
    {
        "Note": "Consumption process:\\n- When a consumer subscribes to a topic/partition, there is a **SubscriptionState** object which keeps track of these topics/partitions and is the source of truth for all the info.\\n- This object also keeps track with the **Consumer Coordinator** in managing the offsets.\\n- When poll is invoked, everything kicks off in a consumer. It gets the metadata of the cluster.\\n- **Fetcher** : This is the guy who does the fetch operations on the cluster.\\n- **Consumer Network client**: This network client which in actual communicates to the cluster.\\n- The Metadata is used by the ConsumerCoordinator to coordinate b/w the cluster. It mainly does: \\n - Being aware of dynamic/automatic topic/partition changes\\n - This changes are also updated in the SubscriptionState object. The Fetcher uses this object to understand which topics/partition should be polled.\\n- The **poll duration** is the time the fetcher will wait for triggering any activity on the n/w client. \\n- Once the records are fetched, they are deserialized and converted to ConsumerRecords and returned to the KafkaConsumer.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Walkthrough: Consumer Polling",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=6&mode=live&start=4&noteid=a31b03c8-5207-4287-bcbb-423cc643425e",
        "Tags": [
            "#kafka",
            "#client",
            "#consumer"
        ]
    },
    {
        "Note": "Every consumer is a **single-threaded operation**. So, there is only one poll loop per Kafka Consumer",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Walkthrough: Message Processing",
        "Time in Clip": "0:12",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=7&mode=live&start=12&noteid=0a7cfff4-42d8-4305-9731-e2fbad164917",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "**The offset is the value representing the last read offset processed by the consumer**\\n\\nCategories of offset:\\n- Last committed offset - The last record which the consumer has processed successfully.\\n- log-end offset - The last offset in the partition log\\n- Un-committed changes - The offset which has not been processed by the consumer, i.e, the cluster doesn't have an ack yet is know as uncommitted changes.\\n\\n- **A consumer will have multiple offsets per partition.**\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "The Consumer OFfset in Detail",
        "Time in Clip": "0:50",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=8&mode=live&start=50&noteid=487db1cb-fbd9-43bc-a94e-ee9012746704",
        "Tags": [
            "#kafka",
            "#consumer",
            "#offset"
        ]
    },
    {
        "Note": "The gap b/w the log-end offset and last committed offset is what makes an application more efficient and robust. This is entirely upto the developer on how to narrow this gap for better performance.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "The Consumer OFfset in Detail",
        "Time in Clip": "2:34",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=8&mode=live&start=154&noteid=73d5763a-f1a4-4253-8a98-9d0a26362ae1",
        "Tags": [
            "#kafka",
            "#consumer",
            "#offset"
        ]
    },
    {
        "Note": "Properties for handling commits to the log:\\n- enable.auto.commit: If set to true, the commit process is entirely managed by kafka. Kafka commits the messages on a freq\\n- auto.commit.interval: This is interval in which it will commit the logs automatically.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "The Consumer OFfset in Detail",
        "Time in Clip": "2:58",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=8&mode=live&start=178&noteid=e74ca51d-d235-4510-baec-d6627a26ff48",
        "Tags": [
            "#kafka",
            "#consumer",
            "#offset"
        ]
    },
    {
        "Note": "\\n- Consumer needs to tell the Kafka cluster that I have processed the message. \\n\\n- This is an automatic job that can be configured by some time interval.\\n\\n- The intent in which your system can tolerate of eventual consistency is determined by its reliability.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "The Consumer OFfset in Detail",
        "Time in Clip": "4:56",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=8&mode=live&start=296&noteid=d1c3c1e5-9114-44e6-b891-54445ae8b44b",
        "Tags": [
            "#kafka",
            "#client",
            "#consumer"
        ]
    },
    {
        "Note": "\\n- Read != committed. The gap b/w these should be considered.\\n- enable.auto.commit = true: How offsets are committed to the cluster. If set to true, kafka automatically commits the offset to the cluster. Else, it is left upto the consumer to commit it.\\n- auto.commit.interval.ms = 5000: Interval in which kafka automatically commits. This prop should be properly looked at and is important in case of error scenarios\\n- auto.offset.reset = \"latest\"/\"earliest\"/\"none\": How the consumer will start reading from a newly added partition\\n- __consumer_offsets is a topic which is used by Kafka to store all the **committed offsets of the consumer**. It contains 50 partitions to store \\nthem. \\n- **Consumer coordinator is responsible for updating this committed offset in the cluster.**\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Offset Behavior and Management",
        "Time in Clip": "1:50",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=9&mode=live&start=110&noteid=01a48997-130f-4f59-8f4b-8a1c060a154c",
        "Tags": [
            "#kafka",
            "#offset",
            "#consumer"
        ]
    },
    {
        "Note": "Offset Management:\\nThere are 2 methods provided to commit the offset in manual mode:\\n- commitSync: This blocks the thread to receive a confirmation from the cluster. Retries until receives a success or unrecoverable error.\\n - retry.backoff.ms: This property tell on what interval should the consumer retry to commit the log.\\n- commitAsync: Non-blocking but non-deterministic. So, you will not get to know when the offset was committed. \\n - Callback option is also given to handle the commit callback\\n\\n- Once the messages are committed by ConsumerCoordinator, it updates the SubscriptionState object so that Fetcher knows which messages have been processed successfully and which it should fetch\\n",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "CommitSync and CommitAsync for Manual Offset Management",
        "Time in Clip": "0:01",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=10&mode=live&start=1&noteid=1ebf5362-432e-4f6f-ba24-43a374cec63c",
        "Tags": [
            "#kafka",
            "#offset",
            "#consumer"
        ]
    },
    {
        "Note": "Why should we have offset management on our own:\\n- Consistency control: We would not know when the offset was committed if we leave it to kafka.\\n- Atomicity: Message consumption and processing should be understood properly. \\n - Exactly once vs At-least-once: We can have duplicate messages bcz of multiple partitions... etc. And to have this transnational consistency, we need to manage offsets.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Scaling out with Consumer Groups",
        "Time in Clip": "1:28",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=12&mode=live&start=88&noteid=1598c342-4373-402d-bb3c-575858ecb101",
        "Tags": [
            "#kafka",
            "#offset",
            "#consumer"
        ]
    },
    {
        "Note": "\\n- These are consumers working independently in a team. To enable the consumer to join a consumer group, \"group.id\" setting is used.\\n- The task of consuming the messages is distributed evenly amongst the consumer groups automatically. \\n- Consumer groups establishes:\\n - Parallelism and throughput\\n - Redundancy\\n - Performance\\n- When consumers invoke subscribe with same group.id and common topics. \\n- **Group Coordinator** keeps in sync with the ZK on the processing of messages.\\n- Each consumer is sending a heartbeat with **heartbeat.interval.ms** property. The group coordinator relies on this property if any consumer is alive and able to participate in the group.\\n- session.timeout.ms: This property is used by group coordinator which is the max time the coordinator will wait for the consumer to send a heartbeat. After timeout it assumes, that the consumer is dead.\\n- In case any consumer is dead, the partitions assigned to the dead consumer are re-balanced by the group coordinator to other consumers. In case of failures, offset management plays a really important role. \\n- So, if the offset was not committed before failure, the newly assigned consumer will have to process the messages again.\\n- If any new consumer joins or any partition joins, another re-balance of partitions occur again.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Scaling out with Consumer Groups",
        "Time in Clip": "1:28",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=12&mode=live&start=88&noteid=1577ddba-4db8-473e-ae7c-45be24a1db69",
        "Tags": [
            "#kafka",
            "#consumer",
            "#consumergroups"
        ]
    },
    {
        "Note": "Consumer group re-balance:\\n- Any new consumer uses the last committed offset from the SubscriptionState object.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Consumer Group Coordinator",
        "Time in Clip": "0:05",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=13&mode=live&start=5&noteid=a9d24566-b8a0-4730-9e86-8fe523feedac",
        "Tags": [
            "#kafka",
            "#consumer",
            "#consumergroups"
        ]
    },
    {
        "Note": "Group Coordinator:\\n- Evenly balances available consumer to partitions\\n - 1:1 Consumer-to-partition ratio is maintained if there are equal no of consumers to partitions\\n If there are more consumers than partition, then there will be over-provisioning of consumers and the coordinator can't change this unless there are more available partitions.\\n- Initiates the rebalancing protocol with participation of all the consumer which are responsible for the change context.\\n - Topic change(partition added)\\n - Failures",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Consumer Group Coordinator",
        "Time in Clip": "1:39",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=13&mode=live&start=99&noteid=180709d1-449b-4448-93d0-b598b66f50c5",
        "Tags": [
            "#kafka",
            "#consumer",
            "#consumergroups"
        ]
    },
    {
        "Note": "Consumer Configs:\\n- fetch.min.bytes: Minimum bytes which the Fetcher should fetch. This helps in avoided wasted loops in fetching records.\\n- max.fetch.wait.ms: Max time to wait in case min bytes are not met.\\n- max.partition.fetch.bytes: The maximum bytes that should be fetched from the partition. This should be configured based on the consumption efficiency.\\n- max.poll.records: Max number of records should be polled in one poll. These 2 props are used to configure the throttling mechanism.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Configuration and Advanced Topics",
        "Time in Clip": "0:40",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=15&mode=live&start=40&noteid=501cc6a0-c5c6-4629-9ab6-a867cdbf806c",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "Adv topics:\\n- Consumer position control API: This can be used to configure the consumer consumption behaviour.\\n - seek(): Allows to read specific offset\\n - seekToBeginning(): from the beginning\\n - seekToEnd()\\n- Flow Control: These allow which topics/partitions to resume/pause based on the priority.\\n - pause()\\n - resume()\\n- Rebalance Listeners: This listeners listens to any rebalancing in the consumer group and we can then handle the offsets accordingly.",
        "Course": "Getting Started with Apache Kafka",
        "Module": "Consuming Messages with Kafka Consumers and Consumer Groups",
        "Clip": "Configuration and Advanced Topics",
        "Time in Clip": "1:47",
        "URL": "https://app.pluralsight.com/player?course=apache-kafka-getting-started&author=ryan-plant&name=apache-kafka-getting-started-m5&clip=15&mode=live&start=107&noteid=c59d8971-5b6f-496c-bb1f-2b82692e6892",
        "Tags": [
            "#kafka",
            "#consumer"
        ]
    },
    {
        "Note": "Another way to transfer data. So, the data from kafka cluster can be transferred to some data base. \\nWe can use anything to send the data to any where. For example: NoSQL DBs, AWS S3, Graph DBs, RDBMS, Cloud services, Search engines",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Transferring Data with Kafka Connect",
        "Clip": "Why Kafka Connect?",
        "Time in Clip": "0:06",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=6aba6aae-db9b-492a-a967-7f390a18e654&clip=1&mode=live&start=6&noteid=3a03be8c-a3f3-467b-a604-429d8021e614",
        "Tags": [
            "#kafka",
            "#connect"
        ]
    },
    {
        "Note": "Container is an atomic unit of work for scheduling in docker world",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Containers: The Big Picture",
        "Time in Clip": "0:12",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=1&mode=live&start=12&noteid=88ef10d2-5496-4c7c-a947-cc36cdaaf597",
        "Tags": [
            "#coker",
            "#container"
        ]
    },
    {
        "Note": "Container runs a bunch of images(read-only).  Container is a thin writable layer on top of the image(run-time). This is possible with union file systems.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Containers: The Big Picture",
        "Time in Clip": "0:45",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=1&mode=live&start=45&noteid=a992e1ca-e0cf-46a8-9373-4cb37523d16c",
        "Tags": [
            "#docker",
            "#container"
        ]
    },
    {
        "Note": "Anytime container needs to write on some file, it gets the file from the image, makes a copy of it in its own writable layer and makes the write. This is called copy-on-write.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Containers: The Big Picture",
        "Time in Clip": "2:28",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=1&mode=live&start=148&noteid=027a131e-9180-4062-8e65-5b2ae8694f62",
        "Tags": [
            "#docker",
            "#container"
        ]
    },
    {
        "Note": "Linux containers needs linux kernel. Same goes for windows. Every container shares the kernel of the host. So, the kernel is not present in the image of the container.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Containers: The Big Picture",
        "Time in Clip": "2:37",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=1&mode=live&start=157&noteid=26280be8-c761-49c1-9b05-ded2550754dd",
        "Tags": [
            "#docker",
            "#container"
        ]
    },
    {
        "Note": "8s The Kubernetes service create a name and IP\\n- The IP is called ClusterIP\\n- DNS name are registered with cluster DNS on a technology OpenDNS\\n- All Pods can resolve each other using names\\n- All the pods can discover each other using service discovery\\n- All the nodes in the cluster have a NodePort mapped to the DNS name of service. Then the IP can be found and the service can be discovered.",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Services",
        "Clip": "Kubernetes Service Theory",
        "Time in Clip": "3:50",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=7575e74f-d954-4070-92b9-c1b4f7698be6&clip=1&mode=live&start=230&noteid=66933a17-4426-41c0-82eb-033a10d17a0d",
        "Tags": [
            "#k"
        ]
    },
    {
        "Note": "Advantages of Connect:\\n1. Code reuse. If we want to transfer data from one resource to another, the code is almost similar. Hence, we can directly use kafka connect to transfer the data.\\n2. Avoid reinventing the wheeel: There can be a chance that we neglect something which would add up to the overall efficiency. Kafka connect makes use of micro batching to avoid multiple connections to transfer the data. So, the data is transferred in one go by opening and closing the connection and transferring the entire batch of data at once. This can improve the performance.\\n3. Scalability: There are 2 types of kafka connect \\n - Standalone: Only one kafka connect instance is opened on a single machine.\\n - Distributed:",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Transferring Data with Kafka Connect",
        "Clip": "Kafka Connect Architecture",
        "Time in Clip": "4:59",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=6aba6aae-db9b-492a-a967-7f390a18e654&clip=2&mode=live&start=299&noteid=a1c4f078-8c7a-43b8-bb1a-55ed00ce17a7",
        "Tags": [
            "#kafka",
            "#connect"
        ]
    },
    {
        "Note": "8s There are 3 parts to a Service \\n- Cluster IP: Internal cluster connectivity\\n- NodePort: External access via nodes. This adds on a port to connect to the internal n/w. THe value should be in b/w 30000 & 32677\\n- LoadBalancing: External access via cloud load-balancer\\n\\nIf we create a NodePort, we don't need to create a Cluster IP.",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Services",
        "Clip": "Creating Services Imperatively",
        "Time in Clip": "7:56",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=7575e74f-d954-4070-92b9-c1b4f7698be6&clip=2&mode=live&start=476&noteid=9a4b93c8-e33e-4e86-bdb6-620cdf11772b",
        "Tags": [
            "#k"
        ]
    },
    {
        "Note": "Stopping a container does not remove the data in the container",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Diving Deeper",
        "Time in Clip": "8:03",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=2&mode=live&start=483&noteid=93274ae5-7e31-4de5-996d-bb66e318b2e9",
        "Tags": [
            "#docker",
            "#container"
        ]
    },
    {
        "Note": "Ctrl + P + Q is graceful way of getting out of container",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Diving Deeper",
        "Time in Clip": "8:40",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=2&mode=live&start=520&noteid=709b198d-7bed-4466-aa8b-50689b87cd87",
        "Tags": [
            "#docker",
            "#container"
        ]
    },
    {
        "Note": "CMD -Every image has a default process which it runs when started. (docker image inspect). But if we pass something while running the container then it is overwritten at run time.\\n\\nENTRYPOINT - Anything which is passed at runtime will be appended as arguments\\n\\n",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Diving Deeper",
        "Time in Clip": "9:10",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=2&mode=live&start=550&noteid=a71f8cc8-7b95-44cc-af52-9b7aff9ee31c",
        "Tags": [
            "#docker",
            "#container"
        ]
    },
    {
        "Note": "2 types of logs - \\nDaemon logs\\nContainer/App logs\\n    1. STDOUT\\n    2. STDERR\\n\\nWe can also mount a volume in the container to get the logs even when the container is rm",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Logging",
        "Time in Clip": "0:15",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=3&mode=live&start=15&noteid=5ebba747-ceb7-42ce-a3ba-9d2e40467de1",
        "Tags": [
            "#docker",
            "#logs"
        ]
    },
    {
        "Note": "Components of Kafka connect:\\n- Connectors: Connectors are used to connect to some resource. It can be used to either fetch/push the data to resource. Hence we have 2 types of connectors -\\n - Source connector: connects to some source and transfers data to Kafka cluster. For eg: JDBC Source Connector can be used to connect to a DB and run queries.\\n - Sink connector: connects to some resource where the data should be transferred from the Kafka cluster. For eg: AWS S3 connector can be used to connect to AWS S3",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Transferring Data with Kafka Connect",
        "Clip": "Connectors, Converters, Transforms",
        "Time in Clip": "0:34",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=6aba6aae-db9b-492a-a967-7f390a18e654&clip=3&mode=live&start=34&noteid=195bdede-858a-4a3d-afb8-05f48d629622",
        "Tags": [
            "#kafka",
            "#connector"
        ]
    },
    {
        "Note": "Tasks: The connectors cannot do anything on their own. Tasks are nothing but the runtime instance of a connector which perform the actual process of transferring the data. Tasks scale each other in case of distributed environment. Types of tasks: \\n- Converters: To move the data from DB to Kafka cluster, we first need to fetch each row from the DB. This is done by JDBC Source Connector. Now, it is the job of the connector to convert the data into something which Kafka understands. Hence, it is serialized by using a String converter(there are many others available) so that kafka understands it.\\n - Same happens with sink connectors\\n - We can even perform transform(SMT - Simple message transforms) on the messages while moving the data. Once transformed it can go to converter and then to cluster",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Transferring Data with Kafka Connect",
        "Clip": "Connectors, Converters, Transforms",
        "Time in Clip": "1:13",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=6aba6aae-db9b-492a-a967-7f390a18e654&clip=3&mode=live&start=73&noteid=80ab9329-e714-45d9-b53f-7dca29bbc467",
        "Tags": [
            "#kafka",
            "#connect"
        ]
    },
    {
        "Note": "daemon.json file is the default logging file to configure the logging driver. \\n--log-driver --log-opts options to override the logging configurations\\n\\ndocker logs <container> -f",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Logging",
        "Time in Clip": "2:06",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=3&mode=live&start=126&noteid=3b3566a0-21a8-4338-b3ce-d2f4efcd66d3",
        "Tags": [
            "#docker",
            "#logs"
        ]
    },
    {
        "Note": "Application logging takes the STDOUT and STDERR streams and forwards them to logging drivers(can be configured in daemon-logggin.json file). \\n\\njournald can be used to configure logs in Linux systems.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Containers",
        "Clip": "Recap",
        "Time in Clip": "2:56",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=a4e4c9c2-2d73-40ba-bb02-bc5cf1ead946&clip=4&mode=live&start=176&noteid=5b2e7001-e077-404e-9f57-adce6f444c39",
        "Tags": [
            "#docker",
            "#logs"
        ]
    },
    {
        "Note": "Swarm has features for Secure cluster and orchestrator. It is the key to the future of docker.",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "The Big Picture",
        "Time in Clip": "0:56",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=1&mode=live&start=56&noteid=4e8be7e7-02cd-4e15-ad40-456771ae91ce",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "8s  There are replica sets in b/w pod and deploy. They take care of scalability, reliability, desired state.. etc.\\n- We don't interact with replica-set and wrap it with a deploy object.\\n",
        "Course": "Getting Started with Kubernetes",
        "Module": "Kubernetes Deployments",
        "Clip": "Kubernetes Deployment Theory",
        "Time in Clip": "1:26",
        "URL": "https://app.pluralsight.com/player?course=kubernetes-getting-started&author=nigel-poulton&name=08e4adc1-767d-416c-9aea-0f75d73bf3a4&clip=1&mode=live&start=86&noteid=960a5098-1145-47fb-8dbc-050a533c1faa",
        "Tags": [
            "#k",
            "#deploy"
        ]
    },
    {
        "Note": "The nodes in swarm are secured with MTLS(Mutual TLS). So, all managers and workers talk with each other securely. Also the Cluster Store is automatically distributed to all the manager nodes.",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "The Big Picture",
        "Time in Clip": "1:58",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=1&mode=live&start=118&noteid=a30f5bf6-3a1f-4b0b-b0d0-0719f5ad4165",
        "Tags": [
            "#docker",
            "#swarm",
            "#secure"
        ]
    },
    {
        "Note": "There is something called a cluster store which is automatically given to all the managers.",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "The Big Picture",
        "Time in Clip": "2:09",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=1&mode=live&start=129&noteid=0fa57450-fb5e-45be-967b-44ceaebdbb53",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "We can start giving work to Swarm. So, we just tell swarm what to do and it does it. THere are 2 type of works which can be given to swarm - Native swarm and Kubernetes",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "The Big Picture",
        "Time in Clip": "2:17",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=1&mode=live&start=137&noteid=13eb659f-6f9f-4795-ba0b-fed803eb6f77",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "Docker swarm is cluster of docker nodes(manager and worker)",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "The Big Picture",
        "Time in Clip": "3:12",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=1&mode=live&start=192&noteid=dc9bb661-d7f3-45d8-ab9d-10ca43295ebe",
        "Tags": [
            "#docker",
            "#orcestration",
            "#swarm"
        ]
    },
    {
        "Note": "SwarmKit is tool inside docker which powers Swarm mode.\\n\\nMobiengine, containerd, runc are smaller tools which are present inside docker",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "0:36",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=36&noteid=dab0ec5b-52fd-46ec-a708-fb3a3c2c8bfa",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "There are 2 type of modes in docker - Single engine mode(You have to work with each of the containers) and swarm mode(You have to work with the entire cluster and not individual nodes(containers)).",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "1:37",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=97&noteid=e8e889fe-4424-4fb4-af0a-eeb66b4c9af5",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "\\n\\ndocker swarm init -> converts the node to swarm mode. \\n\\nThe 1st node is manager of swarm. and it is elected as leader. \\n\\nThe leader gets the job first when any work gets assigned to the swarm\\n\\nIts the root ca of the swarm. It also issues a client certificate. \\n\\nAlso it creates a cluster store and it automatically distributes it. \\n\\nThere are 2 cryptographic keys which are generated(manager and worker keys).",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "2:45",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=165&noteid=2cd76a78-40fa-4eba-891a-a47b1d0fb1ff",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "\\n- Rest proxy clients are also used to connect to kafka cluster. They act like rest proxies b/w kafka cluster and services.\\n\\n- These are mainly used when the services cannot use kafka or to simplify kafka processing. Since, setting up a kafka cluster can be challenging.\\n\\n- GET/POST methods can be used to send it to REST proxy. There are producers and consumers present in the Rest proxies which connect to the kafka cluster",
        "Course": "Designing Event-driven Applications Using Apache Kafka Ecosystem",
        "Module": "Integrating Applications with REST Proxy",
        "Clip": "REST to the Rescue",
        "Time in Clip": "3:20",
        "URL": "https://app.pluralsight.com/player?course=designing-event-driven-applications-apache-kafka-ecosystem&author=bogdan-sucaciu&name=48a27740-7954-4413-99d7-ff8db12d0de1&clip=2&mode=live&start=200&noteid=28d2192d-a12e-4f8b-9cc5-1f5825a4fd24",
        "Tags": [
            "#kafka",
            "#restproxy"
        ]
    },
    {
        "Note": "Every swarm has a single leader. Any request goes to follower managers, the request is proxied to the leader.\\n\\nBest practice for manager number - 3, 5 or 7.\\n\\nThe managers should be connected to fast and reliable n/w.",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "4:13",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=253&noteid=77fab39a-8ab2-42c4-a2de-e336680dbf54",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "RAFT is a distributed consensus protocol used in Docker swarm as well as Kubernetes",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "5:00",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=300&noteid=4d1ca32f-36f8-4411-a8ae-83e95d64a47b",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "Each node has a certificate issued on joining a swarm. This identifies who the worker/manager is. Is it from the same swarm. Also what its role is.",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "7:23",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=443&noteid=7bac9084-5b35-4716-a073-05d4c803a71b",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "A cluster of managers and workers, a full-on PKI where the lead manager is the root CA, and it issues every node with a client certificate that gets used to mutual authentication, role authorization, and transport encryption. And on top of that, we've got a distributed encrypted cluster store, cryptographic join tokens, and loads more. And the best bit, it's all just built-in and works out of the box.",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Swarm Clustering Deep Dive",
        "Time in Clip": "7:50",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=2&mode=live&start=470&noteid=b7929dee-414f-4e94-acfa-43650d1dd187",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "Ops toggles: particular type of DevOps toggle to gracefully degrade the features on overwhelming loads",
        "Course": "Microservices: Getting Started",
        "Module": "Building Resilient Microservices Architectures",
        "Clip": "Resilience Tactics",
        "Time in Clip": "1:15",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=a59cdd94-3dc5-499e-bf6e-904b2ef1fa67&clip=3&mode=live&start=75&noteid=a2aac848-f0c9-4777-89d2-66ede8d5f01b",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "Amplification effect: When the system is on peak loads and we get into errors. We can have retry mechanism to handle the error cause. But the system is already on the high peaks. This will again lead to more errors. This is called Amplification effect",
        "Course": "Microservices: Getting Started",
        "Module": "Building Resilient Microservices Architectures",
        "Clip": "Resilience Tactics",
        "Time in Clip": "1:36",
        "URL": "https://app.pluralsight.com/player?course=getting-started-microservices&author=floyd-may&name=a59cdd94-3dc5-499e-bf6e-904b2ef1fa67&clip=3&mode=live&start=96&noteid=b0ad9499-b717-4440-a3a1-37cf6906fe85",
        "Tags": [
            "#microservices"
        ]
    },
    {
        "Note": "docker node ls - gives the swarm list\\n\\ndocker swarm join-token manager/worker\\n\\ndocker swarm join-token --rotate worker - rotates the join token and a new token is generated. It should be run on manager. If anyone tries to join the swarm with old token then it will not work. Also the existing workers which have joined using the old token are unaffected",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Building a Secure Swarm",
        "Time in Clip": "1:41",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=3&mode=live&start=101&noteid=2122ec08-79ac-479a-bc4e-c81cad961b1c",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "Restarting a manager opens some security concerns.. Autolock\\n- not enabled by default\\n- Prevents restarted managers from automatically re-joining the swarm.\\n- Prevents accidentally restoring old copies of swarm\\n",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Building a Secure Swarm",
        "Time in Clip": "5:55",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=3&mode=live&start=355&noteid=c820da37-3ca0-4505-b00c-08525fa3f984",
        "Tags": [
            "#docker",
            "#swarm"
        ]
    },
    {
        "Note": "docker swarm update --cert-expiry 90",
        "Course": "Docker Deep Dive",
        "Module": "Building a Secure Swarm",
        "Clip": "Building a Secure Swarm",
        "Time in Clip": "7:52",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=827da4b6-55b5-455a-a39e-15b7923f1481&clip=3&mode=live&start=472&noteid=99fc0a06-1266-4922-9d25-bad1bb9f8568",
        "Tags": [
            "#docker",
            "#security"
        ]
    },
    {
        "Note": "The clusters need to talk to each other and we have n/w for that. \\nTypes of networks -\\n1. Bridge network/NAT - Containers need to be on the same bridge n/w to talk to each other. So, we need port mapping for exposing and using them for communication(Single host networking)\\n2. Overlay n/w - This is layer 2 n/w over multiple nodes. But the overlay n/w is only for containers(Mulit-host networking)\\n3. MACVLAN - Containers are given their own MAC address on the network. So, the containers are part of the public n/w.  Hence, the VMs can talk to them.\\n4. IPVLAN - \\n\\ndocker network create -o encrypted\\nEncryption is out of the box for the control plane(??). For data-plane encryption pass an argument",
        "Course": "Docker Deep Dive",
        "Module": "Container Networking",
        "Clip": "Network Types",
        "Time in Clip": "0:50",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=97b58d47-d08f-4894-88c7-4a7ec4c746ea&clip=1&mode=live&start=50&noteid=92d4114a-915d-4755-a1c4-eff86b96eb95",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "The bridge network is the default n/w which is present and any new container will be put on this n/w if we don't tell it to be.",
        "Course": "Docker Deep Dive",
        "Module": "Container Networking",
        "Clip": "Network Types",
        "Time in Clip": "4:19",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=97b58d47-d08f-4894-88c7-4a7ec4c746ea&clip=1&mode=live&start=259&noteid=8021a28a-c453-40df-bec3-90c58a0fc886",
        "Tags": [
            "#docker",
            "#network"
        ]
    },
    {
        "Note": "Network services -\\n1. Service Discovery - allows the discovery of service. \\n- Every new service gets a name\\n- Names are registered with Swarm DNS\\n- So, every task/container int the service uses this Swarm DNS to reach some other service.\\n- Every node on the same service can ping each other.\\n- Every service can be discovered using the name of the service.\\n\\n2. Load balancing - \\n- Ingress load balancing: External clients can find the service via any of the nodes of the service even the node which doesn't run the service bcz they are on the same n/w.\\n- Internal Load balancing: The request are properly balanced over the services in the swarm.\\n\\n",
        "Course": "Docker Deep Dive",
        "Module": "Container Networking",
        "Clip": "Recap",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=97b58d47-d08f-4894-88c7-4a7ec4c746ea&clip=3&mode=live&start=4&noteid=a09bf9f5-1b9b-4e62-9c2b-4d3f11f58621",
        "Tags": [
            "#docker",
            "#network",
            "#service"
        ]
    },
    {
        "Note": "Every container comes with non-persistence storage inside the container. It is mostly managed by storage driver/graph driver.",
        "Course": "Docker Deep Dive",
        "Module": "Working with Volumes and Persistent Data",
        "Clip": "The Big Picture",
        "Time in Clip": "1:43",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2a55c940-a9be-482b-ad49-dedc6f3b7cf2&clip=1&mode=live&start=103&noteid=55b9d649-732a-4e0e-a918-e5d411b2fe3f",
        "Tags": [
            "#docker",
            "#volumes"
        ]
    },
    {
        "Note": "It is something that is mounted into the container and is outside of the container space. So, the volume data is unimpacted when a container is removed",
        "Course": "Docker Deep Dive",
        "Module": "Working with Volumes and Persistent Data",
        "Clip": "The Big Picture",
        "Time in Clip": "2:17",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2a55c940-a9be-482b-ad49-dedc6f3b7cf2&clip=1&mode=live&start=137&noteid=e8a242b5-7025-44c8-a98e-6d43f22e5ad4",
        "Tags": [
            "#docker",
            "#volume"
        ]
    },
    {
        "Note": "docker container run -dit --mount source=<vol_name>,target=</vol_target_dir_in_container> alpine\\n\\nIf the volume doesn't exist then that volume is created when the container runs",
        "Course": "Docker Deep Dive",
        "Module": "Working with Volumes and Persistent Data",
        "Clip": "Attaching Volumes to Containers",
        "Time in Clip": "1:09",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2a55c940-a9be-482b-ad49-dedc6f3b7cf2&clip=3&mode=live&start=69&noteid=beffe751-0cca-4dc4-829f-76af528d3e99",
        "Tags": [
            "#docker",
            "#volume"
        ]
    },
    {
        "Note": "Volumes cannot be deleted if it is attached to some container",
        "Course": "Docker Deep Dive",
        "Module": "Working with Volumes and Persistent Data",
        "Clip": "Attaching Volumes to Containers",
        "Time in Clip": "4:37",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2a55c940-a9be-482b-ad49-dedc6f3b7cf2&clip=3&mode=live&start=277&noteid=57ae5583-cddd-4fa6-bfb6-4ae3ae8c4f29",
        "Tags": [
            "#docker",
            "#volume"
        ]
    },
    {
        "Note": "Volumes work with services as well as like containers. We need to provide the same command for mounting as in containers for the service sub command",
        "Course": "Docker Deep Dive",
        "Module": "Working with Volumes and Persistent Data",
        "Clip": "Attaching Volumes to Containers",
        "Time in Clip": "5:10",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2a55c940-a9be-482b-ad49-dedc6f3b7cf2&clip=3&mode=live&start=310&noteid=f4e6c477-5794-4fc8-824a-09232c142c98",
        "Tags": [
            "#docker",
            "#volume"
        ]
    },
    {
        "Note": "Volumes can also be present in some other machine using plugins... as long as it has docker volume driver",
        "Course": "Docker Deep Dive",
        "Module": "Working with Volumes and Persistent Data",
        "Clip": "Recap",
        "Time in Clip": "1:01",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=2a55c940-a9be-482b-ad49-dedc6f3b7cf2&clip=4&mode=live&start=61&noteid=8e112ece-eaca-4532-b746-fb883b0fd53e",
        "Tags": [
            "#docker",
            "#volume"
        ]
    },
    {
        "Note": "Docker secret is a text blob which is anything that is secret. For ex: password to persistence stores, etc.\\n\\nIt requires Swarm-mode",
        "Course": "Docker Deep Dive",
        "Module": "Working with Secrets",
        "Clip": "The Big Picture",
        "Time in Clip": "0:18",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=38a36f69-0fc6-442c-875e-6ea92313e84d&clip=1&mode=live&start=18&noteid=0504f9df-f3ec-45ea-9dca-88b7cb63e466",
        "Tags": [
            "#docker",
            "#secret"
        ]
    },
    {
        "Note": "docker secret create my-secret  <path_file_containing_secret>\\n\\n- Once the service is created, it can be passed to cluster while creation by --secret option with the command. \\n- This is secret is only passed on to the nodes which run the replica of that service\\n- Also, it is encrypted\\n- Once it passed to the tasks, it gets mounted onto the container at /run/secrets dir in unencrypted form(Linux).",
        "Course": "Docker Deep Dive",
        "Module": "Working with Secrets",
        "Clip": "The Big Picture",
        "Time in Clip": "1:35",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=38a36f69-0fc6-442c-875e-6ea92313e84d&clip=1&mode=live&start=95&noteid=9e404521-3641-477a-b71d-5aa562016f0e",
        "Tags": [
            "#docker",
            "#secret"
        ]
    },
    {
        "Note": "Docker UCP -- UI to manage docker",
        "Course": "Docker Deep Dive",
        "Module": "Deploying in Production with Stacks and Services",
        "Clip": "The Big Picture",
        "Time in Clip": "0:35",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=98ebb041-2983-44dd-a17b-ee409ef50568&clip=1&mode=live&start=35&noteid=3c7b4f56-aea8-45f5-840e-0d6bdf2b9522",
        "Tags": [
            "#docker"
        ]
    },
    {
        "Note": "Use a YAML compose file deploy an entire microservices app",
        "Course": "Docker Deep Dive",
        "Module": "Deploying in Production with Stacks and Services",
        "Clip": "The Big Picture",
        "Time in Clip": "0:42",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=98ebb041-2983-44dd-a17b-ee409ef50568&clip=1&mode=live&start=42&noteid=807dfeb4-5d16-4f9e-9a66-d1a368b55d8b",
        "Tags": [
            "#docker",
            "#stack"
        ]
    },
    {
        "Note": "docker stack deploy -- subcommand",
        "Course": "Docker Deep Dive",
        "Module": "Deploying in Production with Stacks and Services",
        "Clip": "The Big Picture",
        "Time in Clip": "1:54",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=98ebb041-2983-44dd-a17b-ee409ef50568&clip=1&mode=live&start=114&noteid=07523652-2867-4b8a-ab93-ca8e924f32ab",
        "Tags": [
            "#docker",
            "#stack"
        ]
    },
    {
        "Note": "Docker records the specs of each service in the YAML file as the desired state of the entire app then docker manages it as well",
        "Course": "Docker Deep Dive",
        "Module": "Deploying in Production with Stacks and Services",
        "Clip": "The Big Picture",
        "Time in Clip": "2:08",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=98ebb041-2983-44dd-a17b-ee409ef50568&clip=1&mode=live&start=128&noteid=bd47402a-a58f-4878-84e3-0095a286709e",
        "Tags": [
            "#docker",
            "#stack"
        ]
    },
    {
        "Note": "Compose files -\\nThe file contains root tags mainly for components of docker-\\n1. services\\n- image: takes the image used by service\\n- ports: Port it listens on or the port mapping\\n- networks: which network it uses\\n- deploy: How the service will be deployed. We can have more things in this command on how any container will be deployed(replicas, update_config, restart_policy, placement, etc...)\\n2. networks\\n- Which networks will be used\\n3. volumes\\n- Which volumes will be used",
        "Course": "Docker Deep Dive",
        "Module": "Deploying in Production with Stacks and Services",
        "Clip": "Stack Files",
        "Time in Clip": "1:52",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=98ebb041-2983-44dd-a17b-ee409ef50568&clip=2&mode=live&start=112&noteid=770881c0-2693-4eae-a587-d4364c6d176f",
        "Tags": [
            "#docker",
            "#stack"
        ]
    },
    {
        "Note": "If we want to update the stack by scaling or something, we just need to modify the stack file and run the stack deploy command again. With this, docker will automatically update the stack with the updated version of the file",
        "Course": "Docker Deep Dive",
        "Module": "Deploying in Production with Stacks and Services",
        "Clip": "Deploy and Manage Stacks",
        "Time in Clip": "5:06",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=98ebb041-2983-44dd-a17b-ee409ef50568&clip=3&mode=live&start=306&noteid=20ae6646-5d5e-49a3-b168-5b1cf5554a9c",
        "Tags": [
            "#docker",
            "#stack"
        ]
    },
    {
        "Note": "Routing-mesh/Swarm-mode routing mesh\\n- Built on the Transport layer",
        "Course": "Docker Deep Dive",
        "Module": "Enterprise Tooling",
        "Clip": "Layer 7 Load Balancing",
        "Time in Clip": "0:04",
        "URL": "https://app.pluralsight.com/player?course=docker-deep-dive-update&author=nigel-poulton&name=ad3eea79-0473-4b5f-a9b5-2c176d4e5909&clip=6&mode=live&start=4&noteid=9e7f76c2-ca3b-45f7-9e23-12209123e86c",
        "Tags": [
            "#docker",
            "#network"
        ]
    }
]